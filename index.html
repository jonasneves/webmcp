<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0f172a">
  <title>WebMCP PoC — Hospital Explorer</title>
  <script>
    // WebMCP polyfill — conforms to https://webmachinelearning.github.io/webmcp/
    // Drop when browsers implement the spec natively
    if (!navigator.modelContext) {
      navigator.modelContext = {
        _tools: [],
        provideContext({ tools }) { this._tools = tools; },
        registerTool(tool) { this._tools.push(tool); },
        unregisterTool(name) { this._tools = this._tools.filter(t => t.name !== name); },
        clearContext() { this._tools = []; },
      };
    }
  </script>
  <style>
    :root {
      --bg: #0f172a;
      --surface: #1e293b;
      --surface-alt: #334155;
      --border: #475569;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --accent: #38bdf8;
      --accent-dim: #0c4a6e;
      --risk-low: #22c55e;
      --risk-med: #f59e0b;
      --risk-high: #ef4444;
      --flag: #f59e0b;
      --radius: 8px;
      --radius-lg: 12px;
      --font: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --mono: ui-monospace, 'SF Mono', SFMono-Regular, Menlo, monospace;
      --transition: 150ms ease;
    }

    @media (prefers-reduced-motion: reduce) {
      * { transition: none !important; animation: none !important; }
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font);
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      border-bottom: 1px solid var(--border);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    header h1 {
      font-size: 18px;
      font-weight: 600;
    }

    .status-badge {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text-muted);
      padding: 6px 12px;
      background: var(--surface);
      border-radius: 100px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .status-dot.active { background: var(--risk-low); }

    /* Tools panel */
    .tools-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 300ms ease, border-color 300ms ease;
      border-bottom: 1px solid transparent;
    }

    .tools-panel[data-collapsed="false"] {
      max-height: 600px;
      border-bottom-color: var(--border);
    }

    .tools-panel-inner {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      padding: 16px 24px;
    }

    .tools-toggle {
      min-height: 44px;
      padding: 0 12px;
      font-size: 13px;
      font-family: var(--font);
      color: var(--text-muted);
      background: none;
      border: none;
      cursor: pointer;
      transition: color var(--transition);
    }

    .tools-toggle:hover { color: var(--text); }
    .tools-toggle:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    .tool-item {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 12px 16px;
      flex: 1 1 280px;
      max-width: 400px;
    }

    .tool-item-name {
      font-family: var(--mono);
      font-size: 13px;
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 4px;
    }

    .tool-item-badges {
      display: flex;
      gap: 6px;
      margin-bottom: 6px;
    }

    .annotation-badge {
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      padding: 2px 8px;
      border-radius: 100px;
    }

    .annotation-badge.read-only { background: #052e16; color: var(--risk-low); }
    .annotation-badge.idempotent { background: #0c4a6e; color: var(--accent); }
    .annotation-badge.destructive { background: #450a0a; color: var(--risk-high); }
    .annotation-badge.closed-world { background: #451a03; color: var(--risk-med); }

    .tool-item-desc {
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .tool-item.new {
      border: 1px solid var(--accent);
    }

    .tool-item-params {
      font-size: 11px;
      color: var(--accent);
      margin-top: 4px;
      font-family: var(--mono);
    }

    /* Context bar */
    .context-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 4px 0;
      padding: 8px 16px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 1px solid var(--surface-alt);
      min-height: 32px;
      align-items: center;
    }

    .context-bar:empty { display: none; }

    .context-item::after {
      content: '\00b7';
      padding: 0 8px;
      color: var(--border);
    }

    .context-item:last-child::after { display: none; }

    .layout {
      display: grid;
      grid-template-columns: 1fr 380px;
      flex: 1;
      min-height: 0;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; grid-template-rows: 1fr auto; }
      .chat-panel { border-left: none; border-top: 1px solid var(--border); max-height: 50dvh; }
    }

    main { padding: 24px; overflow-y: auto; min-height: 0; }

    .controls {
      display: flex;
      gap: 8px;
      margin-bottom: 24px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      mask-image: linear-gradient(to right, black calc(100% - 32px), transparent);
      -webkit-mask-image: linear-gradient(to right, black calc(100% - 32px), transparent);
      padding-right: 32px;
    }

    .controls::-webkit-scrollbar { display: none; }

    .controls.at-end {
      mask-image: none;
      -webkit-mask-image: none;
      padding-right: 0;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      min-height: 44px;
      padding: 0 16px;
      font-size: 14px;
      font-family: var(--font);
      color: var(--text-muted);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 100px;
      cursor: pointer;
      text-decoration: none;
      white-space: nowrap;
      flex-shrink: 0;
      transition: background var(--transition), color var(--transition), border-color var(--transition);
    }

    .chip:hover { background: var(--surface-alt); color: var(--text); }
    .chip:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .chip.active { background: var(--accent-dim); color: var(--accent); border-color: var(--accent); }

    .chip-separator {
      width: 1px;
      height: 28px;
      background: var(--border);
      align-self: center;
      flex-shrink: 0;
    }

    #display { min-height: 200px; }

    .empty-state {
      padding: 48px 24px;
      text-align: center;
      color: var(--text-muted);
      font-size: 14px;
    }

    /* Loading skeleton */
    @keyframes shimmer {
      0% { background-position: -400px 0; }
      100% { background-position: 400px 0; }
    }

    .loading-skeleton {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .skeleton-row {
      height: 44px;
      border-radius: var(--radius);
      background: linear-gradient(90deg, var(--surface) 25%, var(--surface-alt) 50%, var(--surface) 75%);
      background-size: 800px 44px;
      animation: shimmer 1.5s infinite linear;
    }

    /* Table view */
    .table-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .hospital-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      min-width: 640px;
    }

    .hospital-table th {
      text-align: left;
      padding: 10px 12px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
    }

    .hospital-table td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--surface-alt);
      white-space: nowrap;
    }

    .hospital-table tbody tr {
      cursor: pointer;
      transition: background var(--transition);
    }

    .hospital-table tbody tr:hover { background: var(--surface); }
    .hospital-table tbody tr:focus-visible { outline: 2px solid var(--accent); outline-offset: -2px; }

    .hospital-name-cell {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .risk-badge {
      display: inline-block;
      padding: 2px 10px;
      font-size: 12px;
      font-weight: 600;
      border-radius: 100px;
      letter-spacing: 0.04em;
    }

    .risk-badge.low { background: #052e16; color: var(--risk-low); }
    .risk-badge.medium { background: #451a03; color: var(--risk-med); }
    .risk-badge.high { background: #450a0a; color: var(--risk-high); }

    /* Flag dot */
    .flag-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--flag);
      flex-shrink: 0;
    }

    .flag-note {
      padding: 8px 24px 0;
      font-size: 13px;
      color: var(--flag);
      font-style: italic;
    }

    /* Chart view */
    .chart-container { max-width: 600px; }

    .chart-row {
      display: grid;
      grid-template-columns: 80px 1fr 50px;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .chart-label {
      font-size: 14px;
      font-weight: 500;
      text-align: right;
    }

    .chart-bar-track {
      height: 32px;
      background: var(--surface);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .chart-bar-fill {
      height: 100%;
      border-radius: var(--radius);
      transition: width 400ms ease;
    }

    .chart-bar-fill.low { background: var(--risk-low); }
    .chart-bar-fill.medium { background: var(--risk-med); }
    .chart-bar-fill.high { background: var(--risk-high); }

    .chart-label.low { color: var(--risk-low); }
    .chart-label.medium { color: var(--risk-med); }
    .chart-label.high { color: var(--risk-high); }

    .chart-value {
      font-size: 14px;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    /* Comparison view */
    .compare-table {
      width: 100%;
      max-width: 640px;
      border-collapse: collapse;
      font-size: 14px;
    }

    .compare-table th {
      text-align: left;
      padding: 10px 16px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
    }

    .compare-table td {
      padding: 12px 16px;
      border-bottom: 1px solid var(--surface-alt);
    }

    .compare-metric {
      color: var(--text-muted);
      font-size: 13px;
    }

    .compare-value {
      font-variant-numeric: tabular-nums;
      font-weight: 500;
    }

    .compare-better {
      color: var(--risk-low);
      font-weight: 700;
    }

    /* Detail view */
    .detail-card {
      max-width: 640px;
      background: var(--surface);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }

    .detail-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--surface-alt);
    }

    .detail-header h2 {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .detail-meta {
      font-size: 13px;
      color: var(--text-muted);
    }

    .detail-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1px;
      background: var(--surface-alt);
    }

    .detail-cell {
      padding: 16px 24px;
      background: var(--surface);
    }

    .detail-cell-label {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .detail-cell-value {
      font-size: 18px;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    .payer-bar {
      display: flex;
      height: 12px;
      border-radius: 6px;
      overflow: hidden;
      margin-top: 8px;
    }

    .payer-bar > div { transition: width 400ms ease; }
    .payer-segment-medicaid { background: var(--risk-high); }
    .payer-segment-medicare { background: var(--risk-med); }
    .payer-segment-commercial { background: var(--risk-low); }
    .payer-segment-other { background: #8b5cf6; }

    .payer-bar-wrapper {
      padding: 16px 24px;
    }

    .payer-bar-label {
      margin-bottom: 8px;
    }

    .payer-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      padding: 16px 24px;
      font-size: 13px;
      color: var(--text-muted);
      border-top: 1px solid var(--surface-alt);
    }

    .payer-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .payer-legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .payer-legend-dot.medicaid { background: var(--risk-high); }
    .payer-legend-dot.medicare { background: var(--risk-med); }
    .payer-legend-dot.commercial { background: var(--risk-low); }
    .payer-legend-dot.other { background: #8b5cf6; }

    .color-risk-low { color: var(--risk-low); }
    .color-risk-medium { color: var(--risk-med); }
    .color-risk-high { color: var(--risk-high); }

    .detail-suffix {
      font-size: 14px;
      color: var(--text-muted);
    }

    .view-label {
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 16px;
    }

    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      min-height: 44px;
      padding: 0 16px;
      font-size: 13px;
      font-family: var(--font);
      color: var(--accent);
      background: none;
      border: 1px solid var(--accent-dim);
      border-radius: var(--radius);
      cursor: pointer;
      margin-bottom: 16px;
    }

    .back-btn:hover { background: var(--accent-dim); }
    .back-btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    /* Summary grid */
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }

    .summary-card {
      background: var(--surface);
      border-radius: var(--radius-lg);
      padding: 20px 24px;
    }

    .summary-card-value {
      font-size: 32px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      margin-bottom: 4px;
    }

    .summary-card-label {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .summary-card-meta {
      font-size: 13px;
      color: var(--text-muted);
    }

    /* Chat panel */
    .chat-panel {
      border-left: 1px solid var(--border);
      background: var(--surface);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 1px solid var(--surface-alt);
    }

    .chat-header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .chat-reset {
      min-width: 44px;
      min-height: 32px;
      padding: 0 12px;
      font-size: 11px;
      font-weight: 600;
      font-family: var(--font);
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      background: none;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      cursor: pointer;
      transition: color var(--transition), border-color var(--transition);
    }

    .chat-reset:hover { color: var(--text); border-color: var(--text-muted); }
    .chat-reset:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    .api-key-bar {
      display: none;
      gap: 8px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--surface-alt);
    }

    .api-key-bar.visible {
      display: flex;
    }

    .api-key-bar input {
      flex: 1;
      min-height: 36px;
      padding: 0 12px;
      font-size: 13px;
      font-family: var(--mono);
      color: var(--text);
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    .api-key-bar input::placeholder { color: var(--text-muted); }
    .api-key-bar input:focus { outline: 2px solid var(--accent); outline-offset: -1px; }

    .api-key-toggle {
      min-width: 44px;
      min-height: 36px;
      font-size: 13px;
      font-family: var(--font);
      color: var(--text-muted);
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      cursor: pointer;
    }

    .api-key-toggle:hover { color: var(--text); }
    .api-key-toggle:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .chat-empty {
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
      padding: 24px 16px;
      line-height: 1.6;
    }

    .msg {
      max-width: 90%;
      padding: 10px 14px;
      border-radius: var(--radius-lg);
      font-size: 13px;
      line-height: 1.5;
      word-break: break-word;
    }

    .msg-user {
      align-self: flex-end;
      background: var(--accent-dim);
      color: var(--accent);
      border-bottom-right-radius: 4px;
    }

    .msg-assistant {
      align-self: flex-start;
      background: var(--surface-alt);
      color: var(--text);
      border-bottom-left-radius: 4px;
    }

    .msg-tool {
      align-self: flex-start;
      max-width: 95%;
      padding: 8px 12px;
      font-family: var(--mono);
      font-size: 11px;
      line-height: 1.6;
      color: var(--text-muted);
      background: var(--bg);
      border: 1px solid var(--surface-alt);
      border-radius: var(--radius);
    }

    .msg-tool-name { color: var(--accent); font-weight: 600; }
    .msg-tool-result { color: var(--risk-low); }

    .msg-context {
      align-self: center;
      padding: 6px 16px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      background: none;
      border: 1px dashed var(--border);
      border-radius: 100px;
    }

    .msg-error {
      align-self: center;
      padding: 8px 14px;
      font-size: 12px;
      color: var(--risk-high);
      background: #450a0a;
      border-radius: var(--radius);
    }

    .chat-input-area {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      border-top: 1px solid var(--surface-alt);
    }

    .chat-input-area textarea {
      flex: 1;
      min-height: 44px;
      max-height: 120px;
      padding: 10px 12px;
      font-size: 14px;
      font-family: var(--font);
      color: var(--text);
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      resize: none;
      line-height: 1.4;
    }

    .chat-input-area textarea::placeholder { color: var(--text-muted); }
    .chat-input-area textarea:focus { outline: 2px solid var(--accent); outline-offset: -1px; }

    .chat-send {
      min-width: 44px;
      min-height: 44px;
      font-size: 18px;
      font-family: var(--font);
      color: var(--bg);
      background: var(--accent);
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      transition: opacity var(--transition);
    }

    .chat-send:disabled { opacity: 0.4; cursor: default; }
    .chat-send:not(:disabled):hover { opacity: 0.85; }
    .chat-send:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    .chat-send.stop {
      background: var(--risk-high);
      font-size: 14px;
    }

    @keyframes chat-spin {
      to { transform: rotate(360deg); }
    }

    .chat-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--surface-alt);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: chat-spin 0.6s linear infinite;
      align-self: flex-start;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 8px;
    }

    .summary-count {
      font-size: 13px;
      color: var(--text-muted);
    }

    /* Quick action chips */
    .chat-quick-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 8px 0;
    }

    .quick-action-chip {
      min-height: 44px;
      padding: 10px 16px;
      font-size: 13px;
      font-family: var(--font);
      color: var(--accent);
      background: var(--accent-dim);
      border: 1px solid var(--accent);
      border-radius: var(--radius);
      cursor: pointer;
      text-align: left;
      transition: transform var(--transition), background var(--transition);
    }

    .quick-action-chip:hover { transform: translateX(2px); }
    .quick-action-chip:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    /* Follow-up suggestions */
    .followup-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-self: flex-start;
      padding: 4px 0;
    }

    .followup-chip {
      min-height: 36px;
      padding: 6px 14px;
      font-size: 12px;
      font-family: var(--font);
      color: var(--text-muted);
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 100px;
      cursor: pointer;
      transition: color var(--transition), border-color var(--transition);
    }

    .followup-chip:hover { color: var(--text); border-color: var(--text-muted); }
    .followup-chip:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    /* Toast */
    .toast-container {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
    }

    @keyframes toast-slide-up {
      from { transform: translateY(16px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 16px;
      min-height: 52px;
      padding: 10px 16px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      animation: toast-slide-up 200ms ease;
      white-space: nowrap;
    }

    .toast-message {
      font-size: 14px;
      color: var(--text);
    }

    .toast-undo {
      min-height: 44px;
      padding: 0 14px;
      font-size: 13px;
      font-weight: 600;
      font-family: var(--font);
      color: var(--accent);
      background: none;
      border: 1px solid var(--accent-dim);
      border-radius: var(--radius);
      cursor: pointer;
      transition: background var(--transition);
    }

    .toast-undo:hover { background: var(--accent-dim); }
    .toast-undo:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    @media (max-width: 600px) {
      .toast-container {
        left: 16px;
        right: 16px;
        transform: none;
      }
      .toast { width: 100%; }
    }

    /* Confirmation dialog */
    .confirm-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .confirm-overlay.active {
      display: flex;
    }

    .confirm-dialog {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.5);
    }

    .confirm-title {
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .confirm-tool {
      font-family: var(--mono);
      font-size: 13px;
      color: var(--accent);
      margin-bottom: 4px;
    }

    .confirm-args {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text-muted);
      background: var(--bg);
      padding: 8px 12px;
      border-radius: var(--radius);
      margin-bottom: 16px;
      word-break: break-all;
    }

    .confirm-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .confirm-cancel, .confirm-ok {
      min-height: 44px;
      padding: 0 20px;
      font-size: 14px;
      font-family: var(--font);
      border-radius: var(--radius);
      cursor: pointer;
    }

    .confirm-cancel {
      color: var(--text-muted);
      background: none;
      border: 1px solid var(--border);
    }

    .confirm-cancel:hover { color: var(--text); border-color: var(--text-muted); }

    .confirm-ok {
      color: var(--bg);
      background: var(--accent);
      border: none;
    }

    .confirm-ok:hover { opacity: 0.85; }
    .confirm-cancel:focus-visible, .confirm-ok:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <h1>WebMCP PoC</h1>
      <button class="tools-toggle" id="tools-toggle" aria-expanded="false">&#9660; 9 tools</button>
    </div>
    <div class="status-badge">
      <span class="status-dot" id="status-dot"></span>
      <span id="status-text">Checking...</span>
    </div>
  </header>

  <div class="tools-panel" id="tools-panel" data-collapsed="true">
    <div class="tools-panel-inner" id="tools-panel-inner"></div>
  </div>

  <div class="layout">
    <main>
      <nav class="controls" aria-label="Filters">
        <button class="chip active" data-filter="all">All</button>
        <button class="chip" data-filter="Los Angeles">Los Angeles</button>
        <button class="chip" data-filter="San Francisco">San Francisco</button>
        <button class="chip" data-filter="Sacramento">Sacramento</button>
        <button class="chip" data-filter="San Diego">San Diego</button>
        <div class="chip-separator"></div>
        <button class="chip" data-view="chart">Risk Overview</button>
        <button class="chip" data-filter="high">High Risk Only</button>
        <button class="chip" data-view="trends">County Trends</button>
        <button class="chip" data-view="statewide">Statewide Summary</button>
      </nav>

      <div id="display"></div>
    </main>

    <aside class="chat-panel">
      <div class="chat-header">
        <span>Chat</span>
        <div class="chat-header-actions">
          <button class="chat-reset" id="key-edit" aria-label="Edit API key">Key</button>
          <button class="chat-reset" id="chat-reset">Clear</button>
        </div>
      </div>
      <div class="api-key-bar">
        <input type="password" id="api-key" placeholder="sk-ant-..." autocomplete="off" spellcheck="false" aria-label="Anthropic API key">
        <button class="api-key-toggle" id="key-toggle" aria-label="Toggle key visibility">Show</button>
      </div>
      <div class="context-bar" id="context-bar"></div>
      <div class="chat-messages" id="chat-messages" aria-live="polite"></div>
      <div class="chat-input-area">
        <textarea id="chat-input" placeholder="Ask about hospitals..." rows="1" aria-label="Chat message"></textarea>
        <button class="chat-send" id="chat-send" aria-label="Send message">&uarr;</button>
      </div>
    </aside>
  </div>

  <div class="toast-container" id="toast-container" role="status" aria-live="polite"></div>

  <div class="confirm-overlay" id="confirm-overlay" role="dialog" aria-modal="true" aria-labelledby="confirm-title">
    <div class="confirm-dialog">
      <p class="confirm-title" id="confirm-title">Confirm action</p>
      <p class="confirm-tool" id="confirm-tool"></p>
      <p class="confirm-args" id="confirm-args"></p>
      <div class="confirm-actions">
        <button class="confirm-cancel" id="confirm-cancel">Cancel</button>
        <button class="confirm-ok" id="confirm-ok">Confirm</button>
      </div>
    </div>
  </div>

  <script>
    /* ── Dataset ── */

    let HOSPITALS = [];

    /* ── State ── */

    const flaggedHospitals = new Map();
    let currentView = { type: 'table', data: null, label: null, filters: null };
    let currentToastTimeout = null;
    let previousToolNames = new Set();
    let toolsInitialized = false;

    /* ── Constants ── */

    const QUICK_ACTIONS = [
      'Show high-risk hospitals',
      'Compare MLK and Cedars-Sinai',
      'Show risk chart for Los Angeles',
      'Flag all hospitals over 70% risk',
      'Run triage analysis'
    ];

    const TRIAGE_PROMPT = `Run a full triage analysis of the hospital dataset. Follow these steps in order:
1. First, call summarize_data to get an overview of the full dataset
2. Then, call filter_hospitals with risk "high" to see the high-risk hospitals
3. Compare the two highest-risk hospitals using compare_hospitals
4. Flag the worst-performing hospital with a note explaining why
5. Write a brief synthesis of your findings`;

    /* ── Utilities ── */

    function riskTier(p) {
      if (p >= 0.65) return 'high';
      if (p >= 0.35) return 'medium';
      return 'low';
    }

    function fmt(n, decimals = 1) {
      return n.toFixed(decimals);
    }

    function pct(n) {
      return fmt(n) + '%';
    }

    function matchName(hospital, query) {
      return hospital.name.toLowerCase().includes(query.toLowerCase());
    }

    function filterData({ county, risk, search } = {}) {
      return HOSPITALS.filter(h => {
        if (county && h.county !== county) return false;
        if (risk && riskTier(h.riskProbability) !== risk) return false;
        if (search && !matchName(h, search)) return false;
        return true;
      });
    }

    function scrollDisplayIntoView() {
      if (window.matchMedia('(max-width: 900px)').matches) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      } else {
        display.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function refreshCurrentView() {
      if (currentView.type === 'table') {
        renderTable(currentView.data || HOSPITALS, currentView.label, currentView.filters);
      } else if (currentView.type === 'chart') {
        renderChart(currentView.data || HOSPITALS, currentView.label, currentView.filters);
      } else if (currentView.type === 'detail' && currentView.data) {
        renderDetail(currentView.data);
      } else if (currentView.type === 'comparison' && currentView.data) {
        renderComparison(currentView.data[0], currentView.data[1]);
      }
    }

    /* ── URL State ── */

    function encodeViewToHash() {
      const params = new URLSearchParams();
      params.set('view', currentView.type);
      const f = currentView.filters || {};

      if (currentView.type === 'table') {
        if (f.county) params.set('county', f.county);
        if (f.risk) params.set('risk', f.risk);
      } else if (currentView.type === 'chart') {
        if (f.county) params.set('county', f.county);
      } else if (currentView.type === 'detail' && currentView.data) {
        params.set('name', currentView.data.name);
      } else if (currentView.type === 'comparison' && currentView.data) {
        params.set('h1', currentView.data[0].name);
        params.set('h2', currentView.data[1].name);
      }

      history.replaceState(null, '', '#' + params.toString());
    }

    function decodeHashToView() {
      const hash = location.hash.slice(1);
      if (!hash) return false;

      const params = new URLSearchParams(hash);
      const view = params.get('view');

      if (view === 'table') {
        const county = params.get('county');
        const risk = params.get('risk');
        if (county) {
          renderTable(filterData({ county }), `hospitals in ${county}`, { county });
        } else if (risk) {
          renderTable(filterData({ risk }), `${risk}-risk hospitals`, { risk });
        } else {
          renderTable(HOSPITALS);
        }
        return true;
      }

      if (view === 'chart') {
        const county = params.get('county');
        if (county) {
          renderChart(filterData({ county }), county, { county });
        } else {
          renderChart(HOSPITALS);
        }
        return true;
      }

      if (view === 'detail') {
        const name = params.get('name');
        const h = HOSPITALS.find(h => h.name === name);
        if (h) { renderDetail(h); return true; }
      }

      if (view === 'compare') {
        const h1 = HOSPITALS.find(h => h.name === params.get('h1'));
        const h2 = HOSPITALS.find(h => h.name === params.get('h2'));
        if (h1 && h2) { renderComparison(h1, h2); return true; }
      }

      return false;
    }

    window.addEventListener('hashchange', () => {
      if (HOSPITALS.length) decodeHashToView();
    });

    /* ── Rendering ── */

    const display = document.getElementById('display');

    function renderSkeleton() {
      display.innerHTML = `
        <div class="loading-skeleton">
          ${Array.from({ length: 8 }, (_, i) =>
            `<div class="skeleton-row" style="animation-delay: ${i * 80}ms"></div>`
          ).join('')}
        </div>
      `;
    }

    function renderTable(hospitals, label, filters) {
      currentView = { type: 'table', data: hospitals, label, filters };
      const summary = label || `${hospitals.length} hospitals`;

      if (hospitals.length === 0) {
        display.innerHTML = `<p class="empty-state">No hospitals match the current filters.</p>`;
        encodeViewToHash();
        syncTools();
        return;
      }

      display.innerHTML = `
        <div class="summary-row">
          <p class="view-label">Showing ${summary}</p>
          <span class="summary-count">${hospitals.length} result${hospitals.length !== 1 ? 's' : ''}</span>
        </div>
        <div class="table-scroll">
        <table class="hospital-table">
          <thead>
            <tr>
              <th>Hospital</th>
              <th>County</th>
              <th>Risk</th>
              <th>Medi-Cal</th>
              <th>Equity Burden</th>
              <th>Margin</th>
            </tr>
          </thead>
          <tbody>
            ${hospitals.map(h => {
              const isFlagged = flaggedHospitals.has(h.name);
              return `
              <tr tabindex="0" data-name="${h.name}">
                <td><span class="hospital-name-cell">${isFlagged ? '<span class="flag-dot" title="Flagged"></span>' : ''}${h.name}</span></td>
                <td>${h.county}</td>
                <td><span class="risk-badge ${riskTier(h.riskProbability)}">${riskTier(h.riskProbability)}</span></td>
                <td>${pct(h.mediCalPct)}</td>
                <td>${h.equityBurdenScore}</td>
                <td class="${h.operatingMargin < 0 ? 'color-risk-high' : 'color-risk-low'}">${fmt(h.operatingMargin)}%</td>
              </tr>`;
            }).join('')}
          </tbody>
        </table>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderChart(hospitals, label, filters) {
      currentView = { type: 'chart', data: hospitals, label, filters };
      const tiers = { low: 0, medium: 0, high: 0 };
      hospitals.forEach(h => tiers[riskTier(h.riskProbability)]++);
      const max = Math.max(tiers.low, tiers.medium, tiers.high, 1);
      const title = label || 'all hospitals';

      display.innerHTML = `
        <p class="view-label">Risk distribution across ${title} (${hospitals.length} total)</p>
        <div class="chart-container" role="img" aria-label="Bar chart: ${tiers.low} low risk, ${tiers.medium} medium risk, ${tiers.high} high risk hospitals across ${title}">
          <div class="chart-row">
            <span class="chart-label low">Low</span>
            <div class="chart-bar-track">
              <div class="chart-bar-fill low" style="width: ${(tiers.low / max) * 100}%"></div>
            </div>
            <span class="chart-value">${tiers.low}</span>
          </div>
          <div class="chart-row">
            <span class="chart-label medium">Medium</span>
            <div class="chart-bar-track">
              <div class="chart-bar-fill medium" style="width: ${(tiers.medium / max) * 100}%"></div>
            </div>
            <span class="chart-value">${tiers.medium}</span>
          </div>
          <div class="chart-row">
            <span class="chart-label high">High</span>
            <div class="chart-bar-track">
              <div class="chart-bar-fill high" style="width: ${(tiers.high / max) * 100}%"></div>
            </div>
            <span class="chart-value">${tiers.high}</span>
          </div>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderDetail(hospital) {
      const h = hospital;
      const tier = riskTier(h.riskProbability);
      const flag = flaggedHospitals.get(h.name);
      currentView = { type: 'detail', data: h, label: null, filters: null };

      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <div class="detail-card">
          <div class="detail-header">
            <h2>${flag ? '<span class="flag-dot"></span>' : ''}${h.name}</h2>
            <p class="detail-meta">${h.county} &middot; ${h.type} &middot; ${h.ownership} &middot; <span class="risk-badge ${tier}">${tier} risk</span></p>
          </div>
          ${flag ? `<p class="flag-note">${flag.note.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</p>` : ''}
          <div class="detail-grid">
            <div class="detail-cell">
              <div class="detail-cell-label">Risk Probability</div>
              <div class="detail-cell-value color-risk-${tier}">${pct(h.riskProbability * 100)}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Equity Burden</div>
              <div class="detail-cell-value">${h.equityBurdenScore}<span class="detail-suffix"> / 100</span></div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Operating Margin</div>
              <div class="detail-cell-value ${h.operatingMargin < 0 ? 'color-risk-high' : 'color-risk-low'}">${fmt(h.operatingMargin)}%</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Occupancy Rate</div>
              <div class="detail-cell-value">${pct(h.occupancyRate)}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Licensed Beds</div>
              <div class="detail-cell-value">${h.licensedBeds}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Medi-Cal Share</div>
              <div class="detail-cell-value ${h.mediCalPct > 40 ? 'color-risk-high' : ''}">${pct(h.mediCalPct)}</div>
            </div>
          </div>
          <div class="payer-bar-wrapper">
            <div class="detail-cell-label payer-bar-label">Payer Mix</div>
            <div class="payer-bar">
              <div class="payer-segment-medicaid" style="width: ${h.mediCalPct}%"></div>
              <div class="payer-segment-medicare" style="width: ${h.medicarePct}%"></div>
              <div class="payer-segment-commercial" style="width: ${h.commercialPct}%"></div>
              <div class="payer-segment-other" style="width: ${h.otherPct}%"></div>
            </div>
          </div>
          <div class="payer-legend">
            <span class="payer-legend-item"><span class="payer-legend-dot medicaid"></span> Medi-Cal ${pct(h.mediCalPct)}</span>
            <span class="payer-legend-item"><span class="payer-legend-dot medicare"></span> Medicare ${pct(h.medicarePct)}</span>
            <span class="payer-legend-item"><span class="payer-legend-dot commercial"></span> Commercial ${pct(h.commercialPct)}</span>
            <span class="payer-legend-item"><span class="payer-legend-dot other"></span> Other ${pct(h.otherPct)}</span>
          </div>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderComparison(h1, h2) {
      currentView = { type: 'comparison', data: [h1, h2], label: null, filters: null };

      const metrics = [
        { label: 'Risk Probability', key: 'riskProbability', format: v => pct(v * 100), lowerBetter: true },
        { label: 'Equity Burden', key: 'equityBurdenScore', format: v => `${v} / 100`, lowerBetter: true },
        { label: 'Operating Margin', key: 'operatingMargin', format: v => `${fmt(v)}%`, lowerBetter: false },
        { label: 'Medi-Cal Share', key: 'mediCalPct', format: v => pct(v), lowerBetter: true },
        { label: 'Occupancy Rate', key: 'occupancyRate', format: v => pct(v), lowerBetter: false },
        { label: 'Licensed Beds', key: 'licensedBeds', format: v => v, lowerBetter: false },
      ];

      function betterClass(v1, v2, lowerBetter) {
        if (v1 === v2) return ['', ''];
        const v1Wins = lowerBetter ? v1 < v2 : v1 > v2;
        return v1Wins ? ['compare-better', ''] : ['', 'compare-better'];
      }

      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <p class="view-label">Comparing two hospitals</p>
        <table class="compare-table">
          <thead>
            <tr>
              <th>Metric</th>
              <th>${h1.name}</th>
              <th>${h2.name}</th>
            </tr>
          </thead>
          <tbody>
            ${metrics.map(m => {
              const [c1, c2] = betterClass(h1[m.key], h2[m.key], m.lowerBetter);
              return `
              <tr>
                <td class="compare-metric">${m.label}</td>
                <td class="compare-value ${c1}">${m.format(h1[m.key])}</td>
                <td class="compare-value ${c2}">${m.format(h2[m.key])}</td>
              </tr>`;
            }).join('')}
          </tbody>
        </table>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderCountyTrends(trends) {
      currentView = { type: 'trends', data: trends, label: null, filters: null };
      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <p class="view-label">County comparison (${trends.length} counties)</p>
        <div class="table-scroll">
        <table class="hospital-table">
          <thead>
            <tr>
              <th>County</th>
              <th>Hospitals</th>
              <th>Avg Risk</th>
              <th>Avg Margin</th>
              <th>Avg Equity Burden</th>
            </tr>
          </thead>
          <tbody>
            ${trends.map(t => {
              const tier = riskTier(t.avgRisk);
              return `
              <tr>
                <td>${t.county}</td>
                <td>${t.count}</td>
                <td><span class="risk-badge ${tier}">${fmt(t.avgRisk * 100)}%</span></td>
                <td class="${t.avgMargin < 0 ? 'color-risk-high' : 'color-risk-low'}">${fmt(t.avgMargin)}%</td>
                <td>${fmt(t.avgEquityBurden, 0)}</td>
              </tr>`;
            }).join('')}
          </tbody>
        </table>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderStatewideCards(data) {
      currentView = { type: 'statewide', data, label: null, filters: null };
      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <p class="view-label">Statewide overview</p>
        <div class="summary-grid">
          <div class="summary-card">
            <div class="summary-card-label">Total Hospitals</div>
            <div class="summary-card-value">${data.totalHospitals}</div>
          </div>
          <div class="summary-card">
            <div class="summary-card-label">Total Licensed Beds</div>
            <div class="summary-card-value">${data.totalBeds.toLocaleString()}</div>
          </div>
          <div class="summary-card">
            <div class="summary-card-label">Average Risk</div>
            <div class="summary-card-value color-risk-${riskTier(data.avgRisk)}">${fmt(data.avgRisk * 100)}%</div>
          </div>
          <div class="summary-card">
            <div class="summary-card-label">Risk Distribution</div>
            <div class="summary-card-value">${data.riskDistribution.high} <span class="detail-suffix">high-risk</span></div>
            <div class="summary-card-meta">${data.riskDistribution.medium} medium, ${data.riskDistribution.low} low</div>
          </div>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    /* ── Display event delegation ── */

    display.addEventListener('click', (e) => {
      const row = e.target.closest('tr[data-name]');
      if (row) { showDetail(row.dataset.name); return; }
      const backBtn = e.target.closest('.back-btn');
      if (backBtn) renderTable(HOSPITALS);
    });

    display.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      const row = e.target.closest('tr[data-name]');
      if (row) showDetail(row.dataset.name);
    });

    function showDetail(name) {
      const h = HOSPITALS.find(h => h.name === name);
      if (!h) return;
      renderDetail(h);
      injectViewingContext(name);
    }

    /* ── Bidirectional context ── */

    function injectViewingContext(name) {
      const empty = chatMessages.querySelector('.chat-empty');
      if (empty) empty.remove();

      const el = document.createElement('div');
      el.className = 'msg msg-context';
      el.textContent = `Viewing ${name}`;
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;

      conversationMessages.push({
        role: 'user',
        content: `[User is now viewing the detail card for ${name}]`
      });
    }

    /* ── Toast ── */

    function showToast(message, onUndo) {
      dismissToast();

      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'toast';

      const msgSpan = document.createElement('span');
      msgSpan.className = 'toast-message';
      msgSpan.textContent = message;
      toast.appendChild(msgSpan);

      const undoBtn = document.createElement('button');
      undoBtn.className = 'toast-undo';
      undoBtn.textContent = 'Undo';
      undoBtn.addEventListener('click', () => {
        dismissToast();
        onUndo();
      });
      toast.appendChild(undoBtn);

      container.appendChild(toast);
      currentToastTimeout = setTimeout(dismissToast, 5000);
    }

    function dismissToast() {
      if (currentToastTimeout) {
        clearTimeout(currentToastTimeout);
        currentToastTimeout = null;
      }
      document.getElementById('toast-container').innerHTML = '';
    }

    /* ── Persistence ── */

    function persistFlags() {
      const data = [...flaggedHospitals.entries()].map(([name, flag]) => ({ name, ...flag }));
      localStorage.setItem('webmcp-flags', JSON.stringify(data));
    }

    function loadFlags() {
      try {
        const data = JSON.parse(localStorage.getItem('webmcp-flags') || '[]');
        data.forEach(({ name, ...flag }) => flaggedHospitals.set(name, flag));
      } catch {}
    }

    /* ── Confirmation dialog ── */

    function showConfirmDialog(toolName, args) {
      return new Promise(resolve => {
        const overlay = document.getElementById('confirm-overlay');
        document.getElementById('confirm-tool').textContent = toolName;
        document.getElementById('confirm-args').textContent = JSON.stringify(args, null, 2);
        overlay.classList.add('active');

        const ok = document.getElementById('confirm-ok');
        const cancel = document.getElementById('confirm-cancel');
        const focusable = [cancel, ok];

        function onTrap(e) {
          if (e.key !== 'Tab') return;
          const idx = focusable.indexOf(document.activeElement);
          if (e.shiftKey) {
            if (idx <= 0) { e.preventDefault(); focusable[focusable.length - 1].focus(); }
          } else {
            if (idx >= focusable.length - 1) { e.preventDefault(); focusable[0].focus(); }
          }
        }

        function cleanup() {
          overlay.classList.remove('active');
          ok.removeEventListener('click', onOk);
          cancel.removeEventListener('click', onCancel);
          overlay.removeEventListener('keydown', onTrap);
        }

        function onOk() { cleanup(); resolve(true); }
        function onCancel() { cleanup(); resolve(false); }

        ok.addEventListener('click', onOk);
        cancel.addEventListener('click', onCancel);
        overlay.addEventListener('keydown', onTrap);
        ok.focus();
      });
    }

    /* ── Keyboard shortcuts ── */

    document.addEventListener('keydown', (e) => {
      if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey && !e.target.matches('input, textarea')) {
        chatInput.focus();
      }
      if (e.key === 'Escape') {
        const overlay = document.getElementById('confirm-overlay');
        if (overlay && overlay.classList.contains('active')) {
          document.getElementById('confirm-cancel').click();
          return;
        }
        const panel = document.getElementById('tools-panel');
        if (panel.dataset.collapsed === 'false') { toggleToolsPanel(); return; }
        dismissToast();
      }
    });

    /* ── Controls scroll fade ── */

    const controlsNav = document.querySelector('.controls');
    function updateScrollFade() {
      const atEnd = controlsNav.scrollLeft + controlsNav.clientWidth >= controlsNav.scrollWidth - 4;
      controlsNav.classList.toggle('at-end', atEnd);
    }
    controlsNav.addEventListener('scroll', updateScrollFade, { passive: true });
    updateScrollFade();

    /* ── Quick actions ── */

    function renderQuickActions() {
      const container = document.createElement('div');
      container.className = 'chat-quick-actions';
      container.id = 'quick-actions';

      QUICK_ACTIONS.forEach(prompt => {
        const btn = document.createElement('button');
        btn.className = 'quick-action-chip';
        btn.textContent = prompt;
        btn.addEventListener('click', () => {
          const actual = prompt === 'Run triage analysis' ? TRIAGE_PROMPT : prompt;
          sendMessage({ display: prompt, prompt: actual });
        });
        container.appendChild(btn);
      });

      chatMessages.appendChild(container);
    }

    /* ── Follow-up suggestions ── */

    function getFollowupSuggestions() {
      const suggestions = [];

      switch (currentView.type) {
        case 'table': {
          suggestions.push('Show risk chart');
          const highRisk = (currentView.data || HOSPITALS)
            .filter(h => riskTier(h.riskProbability) === 'high')
            .sort((a, b) => b.riskProbability - a.riskProbability);
          if (highRisk.length >= 2) {
            suggestions.push(`Compare ${highRisk[0].name} and ${highRisk[1].name}`);
          }
          break;
        }
        case 'chart':
          suggestions.push('Show table view');
          suggestions.push('Filter to high risk only');
          break;
        case 'detail': {
          const h = currentView.data;
          suggestions.push(`Flag ${h.name}`);
          const similar = HOSPITALS
            .filter(other => other.name !== h.name)
            .sort((a, b) =>
              Math.abs(a.riskProbability - h.riskProbability) - Math.abs(b.riskProbability - h.riskProbability)
            );
          if (similar.length) {
            suggestions.push(`Compare with ${similar[0].name}`);
          }
          break;
        }
        case 'comparison': {
          const [h1, h2] = currentView.data;
          const worse = h1.riskProbability > h2.riskProbability ? h1 : h2;
          suggestions.push(`Show detail for ${worse.name}`);
          suggestions.push(`Flag ${worse.name}`);
          break;
        }
      }

      return suggestions.slice(0, 2);
    }

    function renderFollowupSuggestions() {
      clearFollowupSuggestions();
      const suggestions = getFollowupSuggestions();
      if (!suggestions.length) return;

      const container = document.createElement('div');
      container.className = 'followup-suggestions';
      container.id = 'followup-suggestions';

      suggestions.forEach(text => {
        const btn = document.createElement('button');
        btn.className = 'followup-chip';
        btn.textContent = text;
        btn.addEventListener('click', () => {
          sendMessage({ prompt: text });
        });
        container.appendChild(btn);
      });

      chatMessages.appendChild(container);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function clearFollowupSuggestions() {
      const existing = document.getElementById('followup-suggestions');
      if (existing) existing.remove();
    }

    /* ── Dynamic tools ── */

    function getContextualTools() {
      const tools = [];
      if (flaggedHospitals.size > 0) {
        tools.push({
          name: 'review_flags',
          title: 'Review Flags',
          description: `Show all ${flaggedHospitals.size} currently flagged hospitals with their notes and risk metrics.`,
          readOnlyHint: true,
          idempotentHint: true,
          destructiveHint: false,
          openWorldHint: false,
          schema: { type: 'object', properties: {} },
          exec: async () => {
            const flagged = [...flaggedHospitals.keys()]
              .map(name => HOSPITALS.find(h => h.name === name))
              .filter(Boolean);
            renderTable(flagged, 'flagged hospitals');
            return {
              displayed: true,
              count: flagged.length,
              summary: `Showing ${flagged.length} flagged hospital(s).`,
              hospitals: flagged.map(h => ({
                name: h.name,
                note: flaggedHospitals.get(h.name).note,
                risk: riskTier(h.riskProbability)
              }))
            };
          }
        });
        tools.push({
          name: 'clear_all_flags',
          title: 'Clear All Flags',
          description: `Remove all ${flaggedHospitals.size} hospital flags. This action cannot be undone.`,
          readOnlyHint: false,
          idempotentHint: true,
          destructiveHint: true,
          openWorldHint: false,
          schema: { type: 'object', properties: {} },
          exec: async () => {
            const count = flaggedHospitals.size;
            flaggedHospitals.clear();
            persistFlags();
            refreshCurrentView();
            syncTools();
            return { summary: `Cleared ${count} flag(s).` };
          }
        });
      }
      return tools;
    }

    function getActiveTools() {
      const tools = TOOL_DEFS.map(t => {
        if (t.name === 'compare_hospitals') {
          const visible = (currentView.type === 'table' && currentView.data) ? currentView.data : HOSPITALS;
          const names = visible.map(h => h.name);
          return {
            ...t,
            schema: {
              ...t.schema,
              properties: {
                hospital1: { ...t.schema.properties.hospital1, enum: names },
                hospital2: { ...t.schema.properties.hospital2, enum: names }
              }
            }
          };
        }
        return t;
      });
      return [...tools, ...getContextualTools()];
    }

    function getPageContext() {
      const parts = [];
      switch (currentView.type) {
        case 'table':
          parts.push('Table');
          if (currentView.data) parts.push(`${currentView.data.length} hospitals`);
          break;
        case 'chart': parts.push('Chart'); break;
        case 'detail':
          if (currentView.data) parts.push(`Detail: ${currentView.data.name}`);
          break;
        case 'comparison':
          if (currentView.data) parts.push(`${currentView.data[0].name} vs ${currentView.data[1].name}`);
          break;
      }
      if (currentView.filters?.county) parts.push(currentView.filters.county);
      if (currentView.filters?.risk) parts.push(`${currentView.filters.risk} risk`);
      if (flaggedHospitals.size > 0) parts.push(`${flaggedHospitals.size} flagged`);
      return parts;
    }

    function updateContextBar() {
      document.getElementById('context-bar').innerHTML =
        getPageContext().map(p => `<span class="context-item">${p}</span>`).join('');
    }

    function syncTools() {
      const tools = getActiveTools();
      const currentNames = new Set(tools.map(t => t.name));
      const newNames = toolsInitialized
        ? new Set([...currentNames].filter(n => !previousToolNames.has(n)))
        : new Set();
      const removedCount = toolsInitialized
        ? [...previousToolNames].filter(n => !currentNames.has(n)).length
        : 0;

      previousToolNames = currentNames;
      renderToolsPanel(tools, newNames);
      registerTools(tools);
      updateContextBar();

      if (toolsInitialized && (newNames.size > 0 || removedCount > 0)) {
        const parts = [];
        if (newNames.size > 0) parts.push(`${newNames.size} added`);
        if (removedCount > 0) parts.push(`${removedCount} removed`);
        const el = document.createElement('div');
        el.className = 'msg msg-context';
        el.textContent = `${tools.length} tools — ${parts.join(', ')}`;
        chatMessages.appendChild(el);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      toolsInitialized = true;
    }

    /* ── Tools panel ── */

    function renderToolsPanel(tools, newNames = new Set()) {
      const inner = document.getElementById('tools-panel-inner');
      const toggle = document.getElementById('tools-toggle');
      const panel = document.getElementById('tools-panel');
      const collapsed = panel.dataset.collapsed === 'true';
      toggle.innerHTML = `${collapsed ? '&#9660;' : '&#9650;'} ${tools.length} tools`;

      inner.innerHTML = tools.map(t => {
        const badges = [];
        if (t.readOnlyHint) badges.push('<span class="annotation-badge read-only">read-only</span>');
        if (t.idempotentHint) badges.push('<span class="annotation-badge idempotent">idempotent</span>');
        if (t.destructiveHint) badges.push('<span class="annotation-badge destructive">destructive</span>');
        if (!t.openWorldHint) badges.push('<span class="annotation-badge closed-world">closed-world</span>');

        const isNew = newNames.has(t.name);
        const hospitalEnum = Object.entries(t.schema.properties || {})
          .find(([k, v]) => v.enum && (k === 'hospital1' || k === 'hospital2'));
        const paramsHtml = hospitalEnum
          ? `<div class="tool-item-params">${hospitalEnum[1].enum.length} hospitals available</div>`
          : '';
        const desc = t.description.split('.')[0] + '.';

        return `
          <div class="tool-item${isNew ? ' new' : ''}">
            <div class="tool-item-name">${t.name}</div>
            <div class="tool-item-badges">${badges.join('')}</div>
            <div class="tool-item-desc">${desc}</div>
            ${paramsHtml}
          </div>
        `;
      }).join('');
    }

    function toggleToolsPanel() {
      const panel = document.getElementById('tools-panel');
      const toggle = document.getElementById('tools-toggle');
      const collapsed = panel.dataset.collapsed === 'true';
      panel.dataset.collapsed = collapsed ? 'false' : 'true';
      toggle.setAttribute('aria-expanded', collapsed ? 'true' : 'false');
      const tools = getActiveTools();
      toggle.innerHTML = `${collapsed ? '&#9650;' : '&#9660;'} ${tools.length} tools`;
    }

    document.getElementById('tools-toggle').addEventListener('click', toggleToolsPanel);

    /* ── Shared tool definitions ── */

    const TOOL_DEFS = [
      {
        name: 'filter_hospitals',
        title: 'Filter Hospitals',
        description: 'Filter and display California hospitals on the page. Renders a table showing matching hospitals with risk tier, Medi-Cal share, equity burden score, and operating margin. The user can then click any row to see full details.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            county: { type: 'string', enum: ['Los Angeles', 'San Francisco', 'Sacramento', 'San Diego'], description: 'Filter by county' },
            risk: { type: 'string', enum: ['low', 'medium', 'high'], description: 'Filter by ML-predicted risk tier' },
            search: { type: 'string', description: 'Search hospital name (partial match)' }
          }
        },
        exec: async (input) => {
          const filtered = filterData(input);
          const parts = [];
          if (input.county) parts.push(`in ${input.county}`);
          if (input.risk) parts.push(`${input.risk} risk`);
          if (input.search) parts.push(`matching "${input.search}"`);
          const label = parts.length ? parts.join(', ') : 'all hospitals';
          renderTable(filtered, label, { county: input.county, risk: input.risk });
          return { displayed: true, count: filtered.length, summary: `Rendered ${filtered.length} hospitals (${label}). User can now see the table and click any row for details.` };
        }
      },
      {
        name: 'show_risk_chart',
        title: 'Risk Chart',
        description: 'Display a visual bar chart showing the distribution of hospital financial risk tiers (low/medium/high). Renders directly on the page so the user can see the breakdown visually.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            county: { type: 'string', enum: ['Los Angeles', 'San Francisco', 'Sacramento', 'San Diego'], description: 'Limit chart to a specific county' }
          }
        },
        exec: async (input) => {
          const hospitals = input.county ? filterData({ county: input.county }) : HOSPITALS;
          const label = input.county || 'all hospitals';
          renderChart(hospitals, label, { county: input.county });
          const tiers = { low: 0, medium: 0, high: 0 };
          hospitals.forEach(h => tiers[riskTier(h.riskProbability)]++);
          return { displayed: true, summary: `Chart displayed: ${tiers.low} low, ${tiers.medium} medium, ${tiers.high} high risk (${label}).`, distribution: tiers };
        }
      },
      {
        name: 'show_hospital_detail',
        title: 'Hospital Detail',
        description: 'Display a detailed profile card for a specific hospital, showing risk probability, equity burden score, operating margin, payer mix breakdown, occupancy, and bed count. Renders visually on the page.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'Hospital name (partial match supported)' }
          },
          required: ['name']
        },
        exec: async (input) => {
          const hospital = HOSPITALS.find(h => matchName(h, input.name));
          if (!hospital) return { displayed: false, summary: `No hospital found matching "${input.name}".` };
          renderDetail(hospital);
          const tier = riskTier(hospital.riskProbability);
          return { displayed: true, summary: `Showing ${hospital.name} — ${tier} risk, equity burden ${hospital.equityBurdenScore}/100, margin ${fmt(hospital.operatingMargin)}%.` };
        }
      },
      {
        name: 'flag_hospital',
        title: 'Flag Hospital',
        description: 'Flag or unflag a hospital with a note. Flagged hospitals display an amber indicator dot in tables and detail views. Use this to mark hospitals that warrant attention or follow-up.',
        readOnlyHint: false,
        idempotentHint: false,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'Hospital name (partial match supported)' },
            note: { type: 'string', description: 'Reason for flagging (displayed on detail card)' },
            unflag: { type: 'boolean', description: 'Set to true to remove the flag' }
          },
          required: ['name']
        },
        exec: async (input) => {
          const hospital = HOSPITALS.find(h => matchName(h, input.name));
          if (!hospital) return { summary: `No hospital found matching "${input.name}".` };

          if (input.unflag) {
            const previousFlag = flaggedHospitals.get(hospital.name);
            flaggedHospitals.delete(hospital.name);
            persistFlags();
            refreshCurrentView();
            showToast('Flag removed', () => {
              flaggedHospitals.set(hospital.name, previousFlag || { note: 'Flagged for review', timestamp: Date.now() });
              persistFlags();
              refreshCurrentView();
            });
            return { summary: `Removed flag from ${hospital.name}.` };
          }

          const flagData = { note: input.note || 'Flagged for review', timestamp: Date.now() };
          flaggedHospitals.set(hospital.name, flagData);
          persistFlags();
          refreshCurrentView();
          showToast('Hospital flagged', () => {
            flaggedHospitals.delete(hospital.name);
            persistFlags();
            refreshCurrentView();
          });
          return { summary: `Flagged ${hospital.name}: "${input.note || 'Flagged for review'}".` };
        }
      },
      {
        name: 'compare_hospitals',
        title: 'Compare Hospitals',
        description: 'Display a side-by-side comparison table of two hospitals across key metrics: risk probability, equity burden, operating margin, Medi-Cal share, occupancy rate, and licensed beds. Better values are highlighted in green.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            hospital1: { type: 'string', description: 'First hospital name (partial match)' },
            hospital2: { type: 'string', description: 'Second hospital name (partial match)' }
          },
          required: ['hospital1', 'hospital2']
        },
        exec: async (input) => {
          const h1 = HOSPITALS.find(h => matchName(h, input.hospital1));
          const h2 = HOSPITALS.find(h => matchName(h, input.hospital2));
          if (!h1) return { displayed: false, summary: `No hospital found matching "${input.hospital1}".` };
          if (!h2) return { displayed: false, summary: `No hospital found matching "${input.hospital2}".` };
          renderComparison(h1, h2);
          return { displayed: true, summary: `Comparing ${h1.name} vs ${h2.name}. Key differences: risk ${pct(h1.riskProbability * 100)} vs ${pct(h2.riskProbability * 100)}, margin ${fmt(h1.operatingMargin)}% vs ${fmt(h2.operatingMargin)}%.` };
        }
      },
      {
        name: 'summarize_data',
        title: 'Summarize Data',
        description: 'Compute aggregate statistics for the hospital dataset. Returns numerical summaries (averages, distributions, extremes) without rendering any visualization. Use this to analyze data before deciding what to show.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            county: { type: 'string', enum: ['Los Angeles', 'San Francisco', 'Sacramento', 'San Diego'], description: 'Limit summary to a specific county' }
          }
        },
        exec: async (input) => {
          const data = input.county ? filterData({ county: input.county }) : HOSPITALS;
          const avg = (fn) => data.reduce((s, h) => s + fn(h), 0) / data.length;

          const avgMargin = avg(h => h.operatingMargin);
          const avgRisk = avg(h => h.riskProbability);
          const avgEquityBurden = avg(h => h.equityBurdenScore);
          const avgOccupancy = avg(h => h.occupancyRate);
          const totalBeds = data.reduce((s, h) => s + h.licensedBeds, 0);

          const riskDistribution = { low: 0, medium: 0, high: 0 };
          data.forEach(h => riskDistribution[riskTier(h.riskProbability)]++);

          const sorted = [...data].sort((a, b) => b.riskProbability - a.riskProbability);
          const highestRisk = sorted[0];
          const lowestRisk = sorted[sorted.length - 1];

          const scope = input.county || 'all counties';
          return {
            scope,
            count: data.length,
            avgMargin: +avgMargin.toFixed(1),
            avgRisk: +avgRisk.toFixed(2),
            avgEquityBurden: +avgEquityBurden.toFixed(0),
            avgOccupancy: +avgOccupancy.toFixed(1),
            totalBeds,
            riskDistribution,
            highestRisk: { name: highestRisk.name, risk: highestRisk.riskProbability },
            lowestRisk: { name: lowestRisk.name, risk: lowestRisk.riskProbability },
            summary: `${data.length} hospitals (${scope}): avg risk ${(avgRisk * 100).toFixed(0)}%, avg margin ${avgMargin.toFixed(1)}%, ${riskDistribution.high} high-risk. Highest: ${highestRisk.name} (${(highestRisk.riskProbability * 100).toFixed(0)}%), lowest: ${lowestRisk.name} (${(lowestRisk.riskProbability * 100).toFixed(0)}%).`
          };
        }
      },
      {
        name: 'export_flagged',
        title: 'Export Flagged',
        description: 'Download a CSV file of all currently flagged hospitals with their flag notes and key metrics. Produces a file download, does not render a visualization.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {}
        },
        exec: async () => {
          if (flaggedHospitals.size === 0) return { summary: 'No hospitals are currently flagged.' };

          const headers = ['Name', 'County', 'Risk Tier', 'Risk Probability', 'Operating Margin', 'Equity Burden', 'Flag Note', 'Flagged At'];
          const rows = [...flaggedHospitals.entries()].map(([name, flag]) => {
            const h = HOSPITALS.find(h => h.name === name);
            return [name, h.county, riskTier(h.riskProbability), h.riskProbability, h.operatingMargin, h.equityBurdenScore, flag.note, new Date(flag.timestamp).toISOString()];
          });

          const csv = [headers, ...rows].map(r => r.map(v => `"${v}"`).join(',')).join('\n');
          const blob = new Blob([csv], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'flagged-hospitals.csv';
          a.click();
          URL.revokeObjectURL(url);

          return { summary: `Exported ${flaggedHospitals.size} flagged hospital(s) as CSV.` };
        }
      },
      {
        name: 'show_county_trends',
        title: 'County Trends',
        description: 'Display a comparison table of aggregate metrics by county, including average risk, margin, and equity burden. Renders a table on the page.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: { type: 'object', properties: {} },
        exec: async () => {
          const counties = {};
          HOSPITALS.forEach(h => {
            if (!counties[h.county]) counties[h.county] = [];
            counties[h.county].push(h);
          });

          const trends = Object.entries(counties).map(([county, hospitals]) => {
            const avg = (fn) => hospitals.reduce((s, h) => s + fn(h), 0) / hospitals.length;
            return {
              county,
              count: hospitals.length,
              avgRisk: avg(h => h.riskProbability),
              avgMargin: avg(h => h.operatingMargin),
              avgEquityBurden: avg(h => h.equityBurdenScore)
            };
          });

          renderCountyTrends(trends);
          return { displayed: true, summary: `Showing county trends for ${trends.length} counties.` };
        }
      },
      {
        name: 'show_statewide_summary',
        title: 'Statewide Summary',
        description: 'Display summary cards with statewide aggregate metrics including total hospitals, beds, average risk, and risk distribution. Renders cards on the page.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: { type: 'object', properties: {} },
        exec: async () => {
          const avg = (fn) => HOSPITALS.reduce((s, h) => s + fn(h), 0) / HOSPITALS.length;
          const riskDist = { low: 0, medium: 0, high: 0 };
          HOSPITALS.forEach(h => riskDist[riskTier(h.riskProbability)]++);

          renderStatewideCards({
            totalHospitals: HOSPITALS.length,
            totalBeds: HOSPITALS.reduce((s, h) => s + h.licensedBeds, 0),
            avgRisk: avg(h => h.riskProbability),
            riskDistribution: riskDist
          });
          return { displayed: true, summary: `Showing statewide summary: ${HOSPITALS.length} hospitals, ${riskDist.high} high-risk.` };
        }
      }
    ];

    /* ── Button controls (mirror tool functionality) ── */

    document.querySelectorAll('.chip[data-filter]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');

        const filter = btn.dataset.filter;
        if (filter === 'all') {
          renderTable(HOSPITALS);
        } else if (filter === 'high') {
          const filtered = filterData({ risk: 'high' });
          renderTable(filtered, 'high-risk hospitals', { risk: 'high' });
        } else {
          const filtered = filterData({ county: filter });
          renderTable(filtered, `hospitals in ${filter}`, { county: filter });
        }
      });
    });

    document.querySelectorAll('.chip[data-view]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');

        const view = btn.dataset.view;
        if (view === 'chart') {
          renderChart(HOSPITALS);
        } else if (view === 'trends') {
          const tool = TOOL_DEFS.find(t => t.name === 'show_county_trends');
          tool.exec();
        } else if (view === 'statewide') {
          const tool = TOOL_DEFS.find(t => t.name === 'show_statewide_summary');
          tool.exec();
        }
      });
    });

    /* ── WebMCP registration ── */

    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');

    function registerTools(tools) {
      if (!navigator.modelContext) {
        statusText.textContent = 'WebMCP not detected';
        return;
      }

      statusDot.classList.add('active');
      statusText.textContent = 'WebMCP active';

      navigator.modelContext.provideContext({
        tools: tools.map(t => ({
          name: t.name,
          description: t.description,
          inputSchema: t.schema,
          annotations: {
            title: t.title,
            readOnlyHint: t.readOnlyHint,
            destructiveHint: t.destructiveHint,
            idempotentHint: t.idempotentHint,
            openWorldHint: t.openWorldHint
          },
          execute: t.exec
        }))
      });
    }

    /* ── Chat panel ── */

    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const chatReset = document.getElementById('chat-reset');
    const apiKeyInput = document.getElementById('api-key');
    const keyToggle = document.getElementById('key-toggle');

    const SYSTEM_PROMPT = `You are embedded in a WebMCP proof-of-concept that explores California hospital financial data. Your tools render visuals (tables, charts, detail cards, comparisons) directly on the page — the user already sees the full result. You only receive a brief summary.

Rules:
- 1-2 sentences max after a tool call. Never redescribe what the visualization already shows.
- Call tools eagerly. If the user asks to see data, call the tool — don't narrate what you're about to do.
- End with a short follow-up suggestion (one line) so the user knows what else they can explore.
- No markdown formatting — this renders as plain text in a chat bubble.
- No greetings, filler, or preamble.
- You can flag hospitals to mark them for attention. Use flag_hospital when the user wants to mark, note, or bookmark a hospital.
- You can compare two hospitals side-by-side. Use compare_hospitals when the user wants to see differences.
- Use summarize_data to compute aggregate statistics before writing analysis. This tool returns numbers without rendering — use the data to write insights.
- Use export_flagged to download a CSV of all flagged hospitals when the user wants to export or save their flags.
- Use show_county_trends to display a county-level comparison table with aggregate metrics.
- Use show_statewide_summary to display statewide overview cards with totals and risk distribution.
- Your available tools change dynamically based on page state. When hospitals are flagged, review_flags and clear_all_flags become available. Tool schemas also adapt — compare_hospitals only lists currently visible hospitals.`;

    function getClaudeTools() {
      return getActiveTools().map(t => ({ name: t.name, description: t.description, input_schema: t.schema }));
    }

    let conversationMessages = [];
    let chatBusy = false;
    let abortController = null;

    // Restore API key: config.json > localStorage
    const apiKeyBar = document.querySelector('.api-key-bar');
    const keyEditBtn = document.getElementById('key-edit');

    apiKeyInput.value = localStorage.getItem('webmcp-api-key') || '';

    fetch('config.json').then(r => r.ok ? r.json() : null).then(cfg => {
      if (cfg?.apiKey && !apiKeyInput.value) {
        apiKeyInput.value = cfg.apiKey;
        localStorage.setItem('webmcp-api-key', cfg.apiKey);
      }
    }).catch(() => {}).finally(() => {
      if (!apiKeyInput.value) apiKeyBar.classList.add('visible');
    });

    apiKeyInput.addEventListener('input', () => localStorage.setItem('webmcp-api-key', apiKeyInput.value));

    keyEditBtn.addEventListener('click', () => {
      apiKeyBar.classList.toggle('visible');
      if (apiKeyBar.classList.contains('visible')) apiKeyInput.focus();
    });

    keyToggle.addEventListener('click', () => {
      const hidden = apiKeyInput.type === 'password';
      apiKeyInput.type = hidden ? 'text' : 'password';
      keyToggle.textContent = hidden ? 'Hide' : 'Show';
    });

    // Chat reset
    chatReset.addEventListener('click', () => {
      conversationMessages = [];
      chatMessages.innerHTML = '';
      renderQuickActions();
    });

    // Auto-resize textarea
    chatInput.addEventListener('input', () => {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    });

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    chatSend.addEventListener('click', () => {
      if (chatBusy && abortController) {
        abortController.abort();
        return;
      }
      sendMessage();
    });

    function appendMessage(type, content) {
      const empty = chatMessages.querySelector('.chat-empty');
      if (empty) empty.remove();

      const el = document.createElement('div');
      el.className = `msg msg-${type}`;
      el.textContent = content;
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return el;
    }

    function appendToolMsg(toolName, args, result) {
      const empty = chatMessages.querySelector('.chat-empty');
      if (empty) empty.remove();

      const el = document.createElement('div');
      el.className = 'msg msg-tool';
      const nameSpan = document.createElement('span');
      nameSpan.className = 'msg-tool-name';
      nameSpan.textContent = toolName;
      const resultSpan = document.createElement('span');
      resultSpan.className = 'msg-tool-result';
      resultSpan.textContent = '\u2192 ' + result;
      el.append(nameSpan, '(' + JSON.stringify(args) + ')\n', resultSpan);
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function showSpinner() {
      const el = document.createElement('div');
      el.className = 'chat-spinner';
      el.id = 'chat-spinner';
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function hideSpinner() {
      const s = document.getElementById('chat-spinner');
      if (s) s.remove();
    }

    function setInputEnabled(enabled) {
      chatBusy = !enabled;
      chatInput.disabled = !enabled;
      if (enabled) {
        chatSend.disabled = false;
        chatSend.classList.remove('stop');
        chatSend.textContent = '\u2191';
        chatSend.setAttribute('aria-label', 'Send message');
      } else {
        chatSend.disabled = false;
        chatSend.classList.add('stop');
        chatSend.textContent = '\u25A0';
        chatSend.setAttribute('aria-label', 'Stop generation');
      }
    }

    async function sendMessage(opts = {}) {
      const text = opts.prompt || chatInput.value.trim();
      const displayText = opts.display || text;
      const apiKey = apiKeyInput.value.trim();
      if (!text || chatBusy) return;

      if (!apiKey) {
        appendMessage('error', 'Enter your Anthropic API key above.');
        return;
      }

      const quickActions = document.getElementById('quick-actions');
      if (quickActions) quickActions.remove();
      clearFollowupSuggestions();

      appendMessage('user', displayText);
      chatInput.value = '';
      chatInput.style.height = 'auto';

      conversationMessages.push({ role: 'user', content: text });
      abortController = new AbortController();
      setInputEnabled(false);
      showSpinner();

      await runConversation(apiKey, abortController.signal);

      abortController = null;
      setInputEnabled(true);
      chatInput.focus();
    }

    /* ── Streaming API ── */

    async function streamClaudeAPI(apiKey, messages, signal) {
      const res = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        signal,
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true'
        },
        body: JSON.stringify({
          model: 'claude-haiku-4-5-20251001',
          max_tokens: 1024,
          system: SYSTEM_PROMPT,
          messages,
          tools: getClaudeTools(),
          stream: true
        })
      });

      if (!res.ok) {
        const body = await res.text();
        throw new Error(`API ${res.status}: ${body.slice(0, 200)}`);
      }

      return res.body;
    }

    async function* parseSSEStream(body) {
      const reader = body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });

        const lines = buffer.split('\n');
        buffer = lines.pop();

        let currentEvent = null;
        for (const line of lines) {
          if (line.startsWith('event: ')) {
            currentEvent = line.slice(7).trim();
          } else if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data && currentEvent) {
              try {
                yield { event: currentEvent, data: JSON.parse(data) };
              } catch {}
            }
            currentEvent = null;
          }
        }
      }
    }

    async function runConversation(apiKey, signal) {
      while (true) {
        let body;
        try {
          body = await streamClaudeAPI(apiKey, conversationMessages, signal);
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', err.message);
          return;
        }

        const contentBlocks = [];
        let currentTextEl = null;
        let currentTextContent = '';
        let currentToolInput = '';
        let currentBlockType = null;

        try {
          for await (const { event, data } of parseSSEStream(body)) {
            switch (event) {
              case 'content_block_start': {
                const block = data.content_block;
                currentBlockType = block.type;
                if (block.type === 'text') {
                  hideSpinner();
                  currentTextContent = block.text || '';
                  currentTextEl = appendMessage('assistant', currentTextContent);
                } else if (block.type === 'tool_use') {
                  contentBlocks.push({ type: 'tool_use', id: block.id, name: block.name, input: {} });
                  currentToolInput = '';
                }
                break;
              }

              case 'content_block_delta': {
                if (data.delta.type === 'text_delta') {
                  currentTextContent += data.delta.text;
                  if (currentTextEl) currentTextEl.textContent = currentTextContent;
                  chatMessages.scrollTop = chatMessages.scrollHeight;
                } else if (data.delta.type === 'input_json_delta') {
                  currentToolInput += data.delta.partial_json;
                }
                break;
              }

              case 'content_block_stop': {
                if (currentBlockType === 'text' && currentTextContent) {
                  contentBlocks.push({ type: 'text', text: currentTextContent });
                  currentTextEl = null;
                  currentTextContent = '';
                } else if (currentBlockType === 'tool_use') {
                  const toolBlock = contentBlocks[contentBlocks.length - 1];
                  try {
                    toolBlock.input = currentToolInput ? JSON.parse(currentToolInput) : {};
                  } catch {
                    toolBlock.input = {};
                  }
                  currentToolInput = '';
                }
                currentBlockType = null;
                break;
              }

              case 'message_delta':
                break;
            }
          }
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', 'Stream interrupted: ' + err.message);
          return;
        }

        // Add the full assistant message to conversation history
        conversationMessages.push({ role: 'assistant', content: contentBlocks });

        // Check for tool use
        const toolUses = contentBlocks.filter(b => b.type === 'tool_use');
        if (toolUses.length === 0) {
          hideSpinner();
          renderFollowupSuggestions();
          return;
        }

        // Execute tools and gather results
        const toolResults = [];
        for (const tu of toolUses) {
          const def = getActiveTools().find(t => t.name === tu.name);
          let result;
          if (def) {
            if (!def.readOnlyHint) {
              const confirmed = await showConfirmDialog(def.title, tu.input);
              if (!confirmed) {
                result = { summary: `User declined: ${def.title}` };
                appendToolMsg(tu.name, tu.input, result.summary);
                toolResults.push({ type: 'tool_result', tool_use_id: tu.id, content: JSON.stringify(result) });
                continue;
              }
            }
            result = await def.exec(tu.input);
            appendToolMsg(tu.name, tu.input, result.summary);
            if (result.displayed) scrollDisplayIntoView();
          } else {
            result = { error: `Unknown tool: ${tu.name}` };
          }
          toolResults.push({
            type: 'tool_result',
            tool_use_id: tu.id,
            content: JSON.stringify(result)
          });
        }

        conversationMessages.push({ role: 'user', content: toolResults });
        showSpinner();
      }
    }

    /* ── Init ── */

    async function init() {
      renderSkeleton();

      try {
        const res = await fetch('hospitals.json');
        HOSPITALS = await res.json();
      } catch (err) {
        display.innerHTML = `<p class="msg-error">Failed to load hospital data: ${err.message}</p>`;
        return;
      }

      loadFlags();

      if (!decodeHashToView()) {
        renderTable(HOSPITALS);
      }

      renderQuickActions();
    }

    init();
  </script>
</body>
</html>
