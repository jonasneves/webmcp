<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="robots" content="noindex, nofollow">
  <meta name="theme-color" content="#eef1f7">
  <title>WebMCP PoC — Earthquake Monitor</title>
  <style>
    :root {
      --bg: #eef1f7;
      --surface: #ffffff;
      --surface-alt: #f4f6fb;
      --border: #cdd2df;
      --text: #111827;
      --text-muted: #64748b;
      --accent: #0d9488;
      --accent-dim: #e0fdf9;
      --risk-low: #16a34a;
      --risk-med: #d97706;
      --risk-high: #dc2626;
      --flag: #d97706;
      --badge-green-bg: #dcfce7;
      --badge-amber-bg: #fef3c7;
      --badge-red-bg: #fee2e2;
      --badge-cyan-bg: #e0fdf9;
      --radius-sm: 6px;
      --radius: 10px;
      --radius-lg: 14px;
      --font: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --mono: ui-monospace, 'SF Mono', SFMono-Regular, Menlo, monospace;
      --text-xs: 0.6875rem;
      --text-sm: 0.8125rem;
      --text-base: 0.9375rem;
      --text-lg: 1.125rem;
      --text-xl: 1.375rem;
      --text-2xl: 1.75rem;
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 16px;
      --space-lg: 24px;
      --space-xl: 32px;
      --space-2xl: 48px;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.06);
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.10), 0 1px 4px rgba(0, 0, 0, 0.05);
      --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.15), 0 4px 8px rgba(0, 0, 0, 0.08);
      --ease: cubic-bezier(0.2, 0.8, 0.2, 1);
      --duration: 150ms;
      --duration-slow: 300ms;
    }

    html[data-theme="dark"] {
      --bg: #0f1117;
      --surface: #1a1d24;
      --surface-alt: #21252d;
      --border: #2d3139;
      --text: #e8eaf0;
      --text-muted: #8b92a5;
      --accent: #2dd4bf;
      --accent-dim: #0f3935;
      --risk-low: #22c55e;
      --risk-med: #f59e0b;
      --risk-high: #ef4444;
      --flag: #f59e0b;
      --badge-green-bg: #052e16;
      --badge-amber-bg: #3d1f00;
      --badge-red-bg: #3d0a0a;
      --badge-cyan-bg: #0f3935;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2);
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.35), 0 1px 4px rgba(0, 0, 0, 0.2);
      --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5), 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    @media (prefers-reduced-motion: reduce) {
      * { transition: none !important; animation: none !important; }
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    :focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    body {
      font-family: var(--font);
      font-size: var(--text-base);
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      height: 100dvh;
      display: flex;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
    }

    .main-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 52px;
      padding: 0 var(--space-lg);
      border-bottom: none;
      background: #111827;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
    }

    html[data-theme="dark"] header {
      background: var(--surface);
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.04);
      border-bottom: 1px solid var(--border);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    header h1 {
      font-size: var(--text-base);
      font-weight: 600;
      letter-spacing: -0.02em;
      color: rgba(255, 255, 255, 0.92);
    }

    html[data-theme="dark"] header h1 { color: var(--text); }

    header .settings-btn { color: rgba(255, 255, 255, 0.5); }
    header .settings-btn:hover,
    header .settings-btn[aria-expanded="true"] {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.15);
      color: rgba(255, 255, 255, 0.9);
    }
    html[data-theme="dark"] header .settings-btn { color: var(--text-muted); }
    html[data-theme="dark"] header .settings-btn:hover,
    html[data-theme="dark"] header .settings-btn[aria-expanded="true"] {
      background: var(--surface-alt);
      border-color: var(--border);
      color: var(--text);
    }

    /* Tools panel */
    .tools-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-slow) var(--ease), border-color var(--duration-slow) var(--ease);
      border-bottom: 1px solid transparent;
    }

    .tools-panel[data-collapsed="false"] {
      max-height: 600px;
      border-bottom-color: var(--border);
    }

    .tools-panel-inner {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      padding: var(--space-md) var(--space-lg);
    }

    .tools-toggle {
      min-height: 44px;
      padding: 0 12px;
      font-size: var(--text-sm);
      font-family: var(--font);
      color: rgba(255, 255, 255, 0.5);
      background: none;
      border: none;
      cursor: pointer;
      transition: color var(--duration) var(--ease);
    }

    .tools-toggle:hover { color: rgba(255, 255, 255, 0.9); }
    html[data-theme="dark"] .tools-toggle { color: var(--text-muted); }
    html[data-theme="dark"] .tools-toggle:hover { color: var(--text); }

    .tool-item {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 12px var(--space-md);
      flex: 1 1 280px;
      max-width: 400px;
      box-shadow: var(--shadow-sm);
    }

    .tool-item-name {
      font-family: var(--mono);
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--accent);
      margin-bottom: var(--space-xs);
    }

    .tool-item-badges {
      display: flex;
      gap: 6px;
      margin-bottom: 6px;
    }

    .annotation-badge {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      padding: 2px var(--space-sm);
      border-radius: 100px;
    }

    .annotation-badge.read-only { background: var(--badge-green-bg); color: var(--risk-low); }
    .annotation-badge.idempotent { background: var(--badge-cyan-bg); color: var(--accent); }
    .annotation-badge.destructive { background: var(--badge-red-bg); color: var(--risk-high); }
    .annotation-badge.closed-world { background: var(--badge-amber-bg); color: var(--risk-med); }

    .tool-item-desc {
      font-size: var(--text-xs);
      color: var(--text-muted);
      line-height: 1.5;
    }

    .tool-item.new {
      border: 1px solid var(--accent);
    }

    .tool-item-params {
      font-size: var(--text-xs);
      color: var(--accent);
      margin-top: var(--space-xs);
      font-family: var(--mono);
    }

    @media (max-width: 900px) {
      body { flex-direction: column; }
      .chat-panel { border-left: none; border-top: 1px solid var(--border); max-height: 50dvh; width: 100%; }
    }

    main { padding: var(--space-lg); overflow-y: auto; flex: 1; min-height: 0; }

    .controls {
      display: flex;
      gap: var(--space-sm);
      margin-bottom: var(--space-lg);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      mask-image: linear-gradient(to right, black calc(100% - 32px), transparent);
      -webkit-mask-image: linear-gradient(to right, black calc(100% - 32px), transparent);
      padding-right: var(--space-xl);
    }

    .controls::-webkit-scrollbar { display: none; }

    .controls.at-end {
      mask-image: none;
      -webkit-mask-image: none;
      padding-right: 0;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      min-height: 44px;
      padding: 0 var(--space-md);
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--text-muted);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 100px;
      cursor: pointer;
      text-decoration: none;
      white-space: nowrap;
      flex-shrink: 0;
      transition: background var(--duration) var(--ease), color var(--duration) var(--ease), border-color var(--duration) var(--ease);
    }

    .chip:hover { background: var(--surface-alt); color: var(--text); }
    .chip.active { background: var(--accent-dim); color: var(--accent); border-color: var(--accent); }

    .chip-separator {
      width: 1px;
      height: 28px;
      background: var(--border);
      align-self: center;
      flex-shrink: 0;
    }

    #display { min-height: 200px; }

    .empty-state {
      padding: var(--space-2xl) var(--space-lg);
      text-align: center;
      color: var(--text-muted);
      font-size: var(--text-sm);
    }

    /* Loading skeleton */
    @keyframes shimmer {
      0% { background-position: -400px 0; }
      100% { background-position: 400px 0; }
    }

    .loading-skeleton {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .skeleton-row {
      height: 44px;
      border-radius: var(--radius);
      background: linear-gradient(90deg, var(--surface) 25%, var(--surface-alt) 50%, var(--surface) 75%);
      background-size: 800px 44px;
      animation: shimmer 1.5s infinite linear;
    }

    /* Table view */
    .table-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .quake-table {
      width: 100%;
      border-collapse: collapse;
      font-size: var(--text-sm);
      min-width: 640px;
    }

    .quake-table th,
    .compare-table th {
      text-align: left;
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
    }

    .quake-table th {
      padding: 10px 12px;
      white-space: nowrap;
    }

    .quake-table td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--surface-alt);
      white-space: nowrap;
    }

    .quake-table tbody tr {
      cursor: pointer;
      transition: background var(--duration) var(--ease);
    }

    .quake-table tbody tr:hover { background: var(--surface); }
    .quake-table tbody tr:focus-visible { outline: 2px solid var(--accent); outline-offset: -2px; }

    .quake-name-cell {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .risk-badge {
      display: inline-block;
      padding: 2px 10px;
      font-size: var(--text-xs);
      font-weight: 600;
      border-radius: 100px;
      letter-spacing: 0.04em;
    }

    .risk-badge.low { background: var(--badge-green-bg); color: var(--risk-low); }
    .risk-badge.medium { background: var(--badge-amber-bg); color: var(--risk-med); }
    .risk-badge.high { background: var(--badge-red-bg); color: var(--risk-high); }

    /* Flag dot */
    .flag-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--flag);
      flex-shrink: 0;
    }

    .flag-note {
      padding: var(--space-sm) var(--space-lg) 0;
      font-size: var(--text-sm);
      color: var(--flag);
      font-style: italic;
    }

    /* Comparison view */
    .compare-table {
      width: 100%;
      max-width: 640px;
      border-collapse: collapse;
      font-size: var(--text-sm);
    }

    .compare-table th {
      padding: 10px var(--space-md);
    }

    .compare-table td {
      padding: 12px var(--space-md);
      border-bottom: 1px solid var(--surface-alt);
    }

    .compare-metric {
      color: var(--text-muted);
      font-size: var(--text-sm);
    }

    .compare-value {
      font-variant-numeric: tabular-nums;
      font-weight: 500;
    }

    /* Detail view */
    .detail-card {
      max-width: 640px;
      background: var(--surface);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow);
    }

    .detail-header {
      padding: 20px var(--space-lg);
      border-bottom: 1px solid var(--surface-alt);
    }

    .detail-header h2 {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: var(--text-xl);
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: var(--space-xs);
    }

    .detail-meta {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }

    .detail-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1px;
      background: var(--surface-alt);
    }

    .detail-cell {
      padding: var(--space-md) var(--space-lg);
      background: var(--surface);
    }

    .detail-cell-label {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: var(--space-xs);
    }

    .detail-cell-value {
      font-size: var(--text-lg);
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
    }

    .color-risk-low { color: var(--risk-low); }
    .color-risk-medium { color: var(--risk-med); }
    .color-risk-high { color: var(--risk-high); }

    .detail-suffix {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }

    .view-label {
      font-size: var(--text-sm);
      color: var(--text-muted);
      margin-bottom: var(--space-md);
    }

    .chart-container {
      width: 100%;
      min-height: 400px;
    }

    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      min-height: 44px;
      padding: 0 var(--space-md);
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--accent);
      background: none;
      border: 1px solid var(--accent-dim);
      border-radius: var(--radius);
      cursor: pointer;
      margin-bottom: var(--space-md);
      transition: background var(--duration) var(--ease);
    }

    .back-btn:hover { background: var(--accent-dim); }

    /* Summary grid */
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-md);
    }

    .summary-card {
      background: var(--surface);
      border-radius: var(--radius-lg);
      padding: 20px var(--space-lg);
      box-shadow: var(--shadow-sm);
      transition: box-shadow var(--duration) var(--ease), transform var(--duration) var(--ease);
    }

    .summary-card:hover {
      box-shadow: var(--shadow);
      transform: translateY(-1px);
    }

    .summary-card-value {
      font-size: var(--text-2xl);
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
      margin-bottom: var(--space-xs);
    }

    .summary-card-label {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: var(--space-xs);
    }

    .summary-card-meta {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }
  </style>
  <link rel="stylesheet" href="../chat.css">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/marked@15/marked.min.js" as="script">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js" as="script">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js" as="script">
  <script src="https://cdn.jsdelivr.net/npm/marked@15/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
  <div class="main-column">
    <header>
      <div class="header-left">
        <h1>WebMCP PoC</h1>
        <button class="tools-toggle" id="tools-toggle" aria-expanded="false" aria-controls="tools-panel">&#9660; 9 tools</button>
      </div>
      <div class="settings-wrap">
        <button class="settings-btn" id="settings-btn" aria-label="Settings" aria-expanded="false" aria-controls="settings-popover" title="Settings">
          <svg width="15" height="15" viewBox="0 0 15 15" fill="none" aria-hidden="true">
            <path d="M6.08 1.5a.5.5 0 0 0-.495.43l-.198 1.382a4.5 4.5 0 0 0-.968.565L3.1 3.29a.5.5 0 0 0-.617.172L1.5 4.9a.5.5 0 0 0 .1.657l1.1.9A4.5 4.5 0 0 0 2.6 7.5c0 .328.034.648.1.943l-1.1.9a.5.5 0 0 0-.1.657l.984 1.438a.5.5 0 0 0 .617.172l1.319-.588c.298.213.617.398.968.565l.198 1.383a.5.5 0 0 0 .495.43h1.84a.5.5 0 0 0 .495-.43l.198-1.383a4.5 4.5 0 0 0 .968-.565l1.319.588a.5.5 0 0 0 .617-.172L13.4 10a.5.5 0 0 0-.1-.657l-1.1-.9c.066-.295.1-.615.1-.943s-.034-.648-.1-.943l1.1-.9A.5.5 0 0 0 13.5 4.9l-.984-1.438a.5.5 0 0 0-.617-.172l-1.319.588a4.5 4.5 0 0 0-.968-.565L9.415 1.93A.5.5 0 0 0 8.92 1.5H6.08ZM7.5 9.5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Z" fill="currentColor"/>
          </svg>
        </button>
        <div class="settings-popover" id="settings-popover" hidden role="dialog" aria-label="Settings">

          <div class="settings-section">
            <div class="settings-section-label">Appearance</div>
            <div class="theme-toggle" role="group" aria-label="Color theme">
              <button class="theme-opt" data-theme="system">System</button>
              <button class="theme-opt" data-theme="light">Light</button>
              <button class="theme-opt" data-theme="dark">Dark</button>
            </div>
          </div>

          <div class="settings-section">
            <div class="settings-section-label">AI Model</div>
            <select class="chat-model-select" id="model-select" aria-label="Model">
              <option value="anthropic:claude-haiku-4-5-20251001">Claude Haiku 4.5</option>
              <option value="anthropic:claude-sonnet-4-6">Claude Sonnet 4.6</option>
              <option value="local:claude" hidden>Claude &middot; Personal account</option>
              <option value="github:openai/gpt-4.1">GitHub &middot; GPT-4.1</option>
              <option value="github:openai/gpt-4.1-mini">GitHub &middot; GPT-4.1 mini</option>
              <option value="github:openai/gpt-5">GitHub &middot; GPT-5</option>
              <option value="github:openai/gpt-5-mini">GitHub &middot; GPT-5 mini</option>
            </select>
          </div>

          <form class="settings-section" id="chat-claude-bar" onsubmit="event.preventDefault()">
            <div class="settings-section-label">Anthropic API Key</div>
            <div class="settings-auth-row">
              <input type="password" class="chat-auth-input" id="api-key" placeholder="sk-ant-…" autocomplete="off" aria-label="Anthropic API key">
              <button type="submit" class="btn btn-sm" id="key-save">Save</button>
            </div>
          </form>

          <div class="settings-section" id="github-auth-bar">
            <!-- rendered by updateGitHubAuthBar() -->
          </div>

          <div class="settings-notice" id="github-notice" hidden>
            <span>Tool calls may be less reliable than Claude.</span>
            <button class="github-notice-dismiss" id="github-notice-dismiss" aria-label="Dismiss">&#x2715;</button>
          </div>

        </div>
      </div>
    </header>

    <div class="tools-panel" id="tools-panel" data-collapsed="true">
      <div class="tools-panel-inner" id="tools-panel-inner"></div>
    </div>

    <main>
      <nav class="controls" aria-label="Filters">
        <button class="chip active" data-filter="all">All</button>
        <button class="chip" data-filter="mag5">Magnitude 5+</button>
        <button class="chip" data-filter="mag3">Magnitude 3+</button>
        <div class="chip-separator"></div>
        <button class="chip" data-view="chart">Magnitude Chart</button>
        <button class="chip" data-filter="felt">Felt Earthquakes</button>
        <button class="chip" data-filter="recent">Recent 24h</button>
      </nav>

      <div id="display"></div>
    </main>
  </div>

  <aside class="chat-panel">
    <div class="chat-header">
      <span class="chat-header-title">AI Chat</span>
      <span class="chat-model-label" id="chat-model-label"></span>
      <button class="btn btn-sm" id="chat-clear">Clear</button>
    </div>
    <div class="chat-messages" id="chat-messages" aria-live="polite"></div>
    <div class="chat-input-area">
      <div class="chat-input-wrap">
        <textarea class="chat-input" id="chat-input" placeholder="Ask about earthquakes…" rows="1" aria-label="Chat message"></textarea>
        <button class="chat-send-btn" id="chat-send" aria-label="Send message" title="Send">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true">
            <path d="M8 13V3M3.5 7.5L8 3l4.5 4.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <button class="chat-abort-btn" id="chat-abort" hidden aria-label="Stop generating" title="Stop">
          <svg width="11" height="11" viewBox="0 0 11 11" aria-hidden="true">
            <rect width="11" height="11" rx="2" fill="currentColor"/>
          </svg>
        </button>
      </div>
    </div>
  </aside>

  <div class="toast-container" id="toast-container" role="status" aria-live="polite"></div>

  <dialog id="confirm-dialog" aria-labelledby="confirm-title">
    <form method="dialog">
      <p class="dialog-title" id="confirm-title">Confirm action</p>
      <p class="dialog-tool" id="confirm-tool"></p>
      <p class="dialog-args" id="confirm-args"></p>
      <div class="dialog-actions">
        <button class="btn-cancel" value="cancel">Cancel</button>
        <button class="btn-confirm" value="confirm">Confirm</button>
      </div>
    </form>
  </dialog>

  <dialog id="prompt-dialog" aria-labelledby="prompt-title">
    <form method="dialog">
      <p class="dialog-title" id="prompt-title"></p>
      <input type="text" class="dialog-input" id="prompt-input" autocomplete="off">
      <div class="dialog-actions">
        <button class="btn-cancel" value="cancel">Skip</button>
        <button class="btn-confirm" value="confirm">Add</button>
      </div>
    </form>
  </dialog>

  <script>
    /* ── Theme ── */

    (function () {
      const stored = localStorage.getItem('webmcp-theme') || 'light';
      const resolved = stored === 'system'
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
        : stored;
      document.documentElement.dataset.theme = resolved;
    })();

    marked.use({ gfm: true, breaks: true });

    /* ── Dataset ── */

    let EARTHQUAKES = [];

    /* ── State ── */

    const flaggedQuakes = new Map();
    let currentView = { type: 'table', data: null, label: null, filters: null };
    let currentToastTimeout = null;
    let previousToolNames = new Set();
    let toolsInitialized = false;

    /* ── Constants ── */

    const QUICK_ACTIONS = [
      'Show strong earthquakes (5+)',
      'Magnitude distribution as a bar chart',
      'Depth vs magnitude scatter plot',
      'Earthquake severity as a pie chart',
      'Summarize recent seismic activity'
    ];

    /* ── Utilities ── */

    function extractRegion(place) {
      if (!place || !place.includes(',')) return 'Other';
      return place.split(',').pop().trim();
    }

    function severityTier(mag) {
      if (mag >= 7) return 'major';
      if (mag >= 5) return 'strong';
      if (mag >= 3) return 'moderate';
      return 'minor';
    }

    function severityBadgeClass(tier) {
      if (tier === 'minor') return 'low';
      if (tier === 'moderate') return 'medium';
      return 'high';
    }

    function timeAgo(timestamp) {
      const diff = Date.now() - timestamp;
      const seconds = Math.floor(diff / 1000);
      if (seconds < 60) return `${seconds}s ago`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    function fmt(n, decimals = 1) {
      return n.toFixed(decimals);
    }

    function matchPlace(quake, query) {
      return quake.place.toLowerCase().includes(query.toLowerCase());
    }

    function filterData({ min_magnitude, search, time_range, felt } = {}) {
      const now = Date.now();
      return EARTHQUAKES.filter(q => {
        if (min_magnitude != null && q.magnitude < min_magnitude) return false;
        if (search && !matchPlace(q, search)) return false;
        if (time_range === '24h' && (now - q.time) > 86400000) return false;
        if (time_range === '7d' && (now - q.time) > 604800000) return false;
        if (time_range === '30d' && (now - q.time) > 2592000000) return false;
        if (felt && q.felt <= 0) return false;
        return true;
      });
    }

    function scrollDisplayIntoView() {
      if (window.matchMedia('(max-width: 900px)').matches) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      } else {
        display.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function refreshCurrentView() {
      if (currentView.type === 'table') {
        renderTable(currentView.data || EARTHQUAKES, currentView.label, currentView.filters);
      } else if (currentView.type === 'chart' && currentView.data) {
        renderEChart(currentView.data, currentView.label);
      } else if (currentView.type === 'detail' && currentView.data) {
        renderDetail(currentView.data);
      } else if (currentView.type === 'comparison' && currentView.data) {
        renderComparison(currentView.data[0], currentView.data[1]);
      }
    }

    /* ── URL State ── */

    function encodeViewToHash() {
      const params = new URLSearchParams();
      params.set('view', currentView.type);
      const f = currentView.filters || {};

      if (currentView.type === 'table') {
        if (f.min_magnitude) params.set('min_mag', f.min_magnitude);
        if (f.time_range) params.set('time', f.time_range);
        if (f.felt) params.set('felt', '1');
      } else if (currentView.type === 'detail' && currentView.data) {
        params.set('id', currentView.data.id);
      } else if (currentView.type === 'comparison' && currentView.data) {
        params.set('q1', currentView.data[0].id);
        params.set('q2', currentView.data[1].id);
      }

      history.replaceState(null, '', '#' + params.toString());
    }

    function decodeHashToView() {
      const hash = location.hash.slice(1);
      if (!hash) return false;

      const params = new URLSearchParams(hash);
      const view = params.get('view');

      if (view === 'table') {
        const min_magnitude = params.get('min_mag') ? +params.get('min_mag') : null;
        const time_range = params.get('time');
        const felt = params.get('felt') === '1';
        const filters = {};
        if (min_magnitude) filters.min_magnitude = min_magnitude;
        if (time_range) filters.time_range = time_range;
        if (felt) filters.felt = true;
        const filtered = filterData(filters);
        const parts = [];
        if (min_magnitude) parts.push(`magnitude ${min_magnitude}+`);
        if (time_range) parts.push(`last ${time_range}`);
        if (felt) parts.push('felt');
        renderTable(filtered, parts.length ? parts.join(', ') : null, filters);
        return true;
      }

      if (view === 'chart') {
        renderTable(EARTHQUAKES);
        return true;
      }

      if (view === 'detail') {
        const id = params.get('id');
        const q = EARTHQUAKES.find(q => q.id === id);
        if (q) { renderDetail(q); return true; }
      }

      if (view === 'comparison') {
        const q1 = EARTHQUAKES.find(q => q.id === params.get('q1'));
        const q2 = EARTHQUAKES.find(q => q.id === params.get('q2'));
        if (q1 && q2) { renderComparison(q1, q2); return true; }
      }

      return false;
    }

    window.addEventListener('hashchange', () => {
      if (EARTHQUAKES.length) decodeHashToView();
    });

    /* ── Rendering ── */

    const display = document.getElementById('display');

    echarts.registerTheme('webmcp', {
      backgroundColor: 'transparent',
      textStyle: { fontFamily: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif" },
      title: { textStyle: { color: '#f1f5f9' } },
      legend: { textStyle: { color: '#94a3b8' } },
      categoryAxis: {
        axisLine: { lineStyle: { color: '#475569' } },
        axisLabel: { color: '#94a3b8' },
        splitLine: { lineStyle: { color: '#1e293b' } }
      },
      valueAxis: {
        axisLine: { lineStyle: { color: '#475569' } },
        axisLabel: { color: '#94a3b8' },
        splitLine: { lineStyle: { color: '#1e293b' } }
      },
      tooltip: {
        backgroundColor: '#1e293b',
        borderColor: '#475569',
        textStyle: { color: '#f1f5f9' }
      }
    });

    let chartInstance = null;

    function renderEChart(option, label) {
      currentView = { type: 'chart', data: option, label, filters: {} };
      if (chartInstance) { chartInstance.dispose(); chartInstance = null; }
      display.innerHTML = `
        <p class="view-label">${label}</p>
        <div id="chart-container" class="chart-container"></div>
      `;
      const container = document.getElementById('chart-container');
      chartInstance = echarts.init(container, 'webmcp');
      chartInstance.setOption(option);
      encodeViewToHash();
      syncTools();
    }

    window.addEventListener('resize', () => {
      if (chartInstance) chartInstance.resize();
    });

    function renderSkeleton() {
      display.innerHTML = `
        <div class="loading-skeleton">
          ${Array.from({ length: 8 }, (_, i) =>
            `<div class="skeleton-row" style="animation-delay: ${i * 80}ms"></div>`
          ).join('')}
        </div>
      `;
    }

    function renderTable(quakes, label, filters) {
      currentView = { type: 'table', data: quakes, label, filters };
      const summary = label || `${quakes.length} earthquakes`;

      if (quakes.length === 0) {
        display.innerHTML = `<p class="empty-state">No earthquakes match the current filters.</p>`;
        encodeViewToHash();
        syncTools();
        return;
      }

      display.innerHTML = `
        <div class="summary-row">
          <p class="view-label">Showing ${summary}</p>
          <span class="summary-count">${quakes.length} result${quakes.length !== 1 ? 's' : ''}</span>
        </div>
        <div class="table-scroll">
        <table class="quake-table">
          <thead>
            <tr>
              <th>Location</th>
              <th>Magnitude</th>
              <th>Depth (km)</th>
              <th>Time</th>
              <th>Felt</th>
            </tr>
          </thead>
          <tbody>
            ${quakes.map(q => {
              const isFlagged = flaggedQuakes.has(q.id);
              const tier = severityTier(q.magnitude);
              const badgeCls = severityBadgeClass(tier);
              return `
              <tr tabindex="0" data-id="${q.id}">
                <td><span class="quake-name-cell">${isFlagged ? '<span class="flag-dot" title="Flagged"></span>' : ''}${q.place}</span></td>
                <td><span class="risk-badge ${badgeCls}">${fmt(q.magnitude)}</span></td>
                <td>${fmt(q.depth)}</td>
                <td>${timeAgo(q.time)}</td>
                <td>${q.felt || '\u2014'}</td>
              </tr>`;
            }).join('')}
          </tbody>
        </table>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderDetail(quake) {
      const q = quake;
      const tier = severityTier(q.magnitude);
      const badgeCls = severityBadgeClass(tier);
      const flag = flaggedQuakes.get(q.id);
      currentView = { type: 'detail', data: q, label: null, filters: null };

      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <div class="detail-card">
          <div class="detail-header">
            <h2>${flag ? '<span class="flag-dot"></span>' : ''}${q.place}</h2>
            <p class="detail-meta">${q.type} &middot; ${q.status} &middot; ${new Date(q.time).toLocaleString()}</p>
          </div>
          ${flag ? `<p class="flag-note">${flag.note.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</p>` : ''}
          <div class="detail-grid">
            <div class="detail-cell">
              <div class="detail-cell-label">Magnitude</div>
              <div class="detail-cell-value color-risk-${badgeCls}">${fmt(q.magnitude)}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Depth</div>
              <div class="detail-cell-value">${fmt(q.depth)}<span class="detail-suffix"> km</span></div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Significance</div>
              <div class="detail-cell-value">${q.significance}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Felt Reports</div>
              <div class="detail-cell-value">${q.felt || 0}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Tsunami Warning</div>
              <div class="detail-cell-value ${q.tsunami ? 'color-risk-high' : 'color-risk-low'}">${q.tsunami ? 'Yes' : 'No'}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Coordinates</div>
              <div class="detail-cell-value">${fmt(q.lat, 3)}, ${fmt(q.lon, 3)}</div>
            </div>
          </div>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderComparison(q1, q2) {
      currentView = { type: 'comparison', data: [q1, q2], label: null, filters: null };

      const metrics = [
        { label: 'Magnitude', key: 'magnitude', format: v => fmt(v) },
        { label: 'Depth (km)', key: 'depth', format: v => fmt(v) },
        { label: 'Significance', key: 'significance', format: v => v },
        { label: 'Felt Reports', key: 'felt', format: v => v || 0 },
        { label: 'Tsunami Warning', key: 'tsunami', format: v => v ? 'Yes' : 'No' },
      ];

      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <p class="view-label">Comparing two earthquakes</p>
        <table class="compare-table">
          <thead>
            <tr>
              <th>Metric</th>
              <th>${q1.place}</th>
              <th>${q2.place}</th>
            </tr>
          </thead>
          <tbody>
            ${metrics.map(m => `
              <tr>
                <td class="compare-metric">${m.label}</td>
                <td class="compare-value">${m.format(q1[m.key])}</td>
                <td class="compare-value">${m.format(q2[m.key])}</td>
              </tr>`
            ).join('')}
          </tbody>
        </table>
      `;
      encodeViewToHash();
      syncTools();
    }

    /* ── Display event delegation ── */

    display.addEventListener('click', (e) => {
      const row = e.target.closest('tr[data-id]');
      if (row) { showDetail(row.dataset.id); return; }
      const backBtn = e.target.closest('.back-btn');
      if (backBtn) renderTable(EARTHQUAKES);
    });

    display.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      const row = e.target.closest('tr[data-id]');
      if (row) showDetail(row.dataset.id);
    });

    function showDetail(id) {
      const q = EARTHQUAKES.find(q => q.id === id);
      if (!q) return;
      renderDetail(q);
    }

    /* ── Toast ── */

    function showToast(message, onUndo) {
      dismissToast();

      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'toast';

      const msgSpan = document.createElement('span');
      msgSpan.className = 'toast-message';
      msgSpan.textContent = message;
      toast.appendChild(msgSpan);

      const undoBtn = document.createElement('button');
      undoBtn.className = 'toast-undo';
      undoBtn.textContent = 'Undo';
      undoBtn.addEventListener('click', () => {
        dismissToast();
        onUndo();
      });
      toast.appendChild(undoBtn);

      container.appendChild(toast);
      currentToastTimeout = setTimeout(dismissToast, 5000);
    }

    function dismissToast() {
      if (currentToastTimeout) {
        clearTimeout(currentToastTimeout);
        currentToastTimeout = null;
      }
      document.getElementById('toast-container').innerHTML = '';
    }

    /* ── Persistence ── */

    function persistFlags() {
      const data = [...flaggedQuakes.entries()].map(([id, flag]) => ({ id, ...flag }));
      localStorage.setItem('webmcp-eq-flags', JSON.stringify(data));
    }

    function loadFlags() {
      try {
        const data = JSON.parse(localStorage.getItem('webmcp-eq-flags') || '[]');
        data.forEach(({ id, ...flag }) => flaggedQuakes.set(id, flag));
      } catch {}
    }

    /* ── Confirmation dialog ── */

    function showConfirmDialog(toolName, args) {
      const dialog = document.getElementById('confirm-dialog');
      document.getElementById('confirm-tool').textContent = toolName;
      document.getElementById('confirm-args').textContent = JSON.stringify(args, null, 2);
      dialog.returnValue = '';
      dialog.showModal();
      return new Promise(resolve => {
        dialog.addEventListener('close', () => {
          resolve(dialog.returnValue === 'confirm');
        }, { once: true });
      });
    }

    function showPromptDialog(message) {
      const dialog = document.getElementById('prompt-dialog');
      const input = document.getElementById('prompt-input');
      document.getElementById('prompt-title').textContent = message;
      input.value = '';
      dialog.returnValue = '';
      dialog.showModal();
      input.focus();
      function onEnter(e) {
        if (e.key === 'Enter') { e.preventDefault(); dialog.close('confirm'); }
      }
      input.addEventListener('keydown', onEnter);
      return new Promise(resolve => {
        dialog.addEventListener('close', () => {
          input.removeEventListener('keydown', onEnter);
          resolve(dialog.returnValue === 'confirm' ? (input.value || null) : null);
        }, { once: true });
      });
    }

    /* ── Keyboard shortcuts ── */

    document.addEventListener('keydown', (e) => {
      if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey && !e.target.matches('input, textarea')) {
        chatInput.focus();
      }
      if (e.key === 'Escape') {
        if (settingsPopover && !settingsPopover.hidden) { settingsPopover.hidden = true; settingsBtn.setAttribute('aria-expanded', 'false'); return; }
        const panel = document.getElementById('tools-panel');
        if (panel.dataset.collapsed === 'false') { toggleToolsPanel(); return; }
        dismissToast();
      }
    });

    function updateModelLabel() {
      const label = document.getElementById('chat-model-label');
      if (!label) return;
      const sel = modelSelect.options[modelSelect.selectedIndex];
      label.textContent = sel ? sel.textContent.trim() : '';
    }

    /* ── Controls scroll fade ── */

    const controlsNav = document.querySelector('.controls');
    function updateScrollFade() {
      const atEnd = controlsNav.scrollLeft + controlsNav.clientWidth >= controlsNav.scrollWidth - 4;
      controlsNav.classList.toggle('at-end', atEnd);
    }
    controlsNav.addEventListener('scroll', updateScrollFade, { passive: true });
    updateScrollFade();

    /* ── Quick actions ── */

    function renderQuickActions() {
      const container = document.createElement('div');
      container.className = 'chat-quick-actions';
      container.id = 'quick-actions';

      QUICK_ACTIONS.forEach(prompt => {
        const btn = document.createElement('button');
        btn.className = 'suggestion-chip quick-action-chip';
        btn.textContent = prompt;
        btn.addEventListener('click', () => {
          sendMessage({ prompt });
        });
        container.appendChild(btn);
      });

      chatMessages.appendChild(container);
    }

    /* ── Follow-up suggestions ── */

    function getFollowupSuggestions() {
      const suggestions = [];

      switch (currentView.type) {
        case 'table': {
          suggestions.push('Show magnitude chart');
          const strong = (currentView.data || EARTHQUAKES)
            .filter(q => q.magnitude >= 5)
            .sort((a, b) => b.magnitude - a.magnitude);
          if (strong.length >= 2) {
            suggestions.push(`Compare ${strong[0].place} and ${strong[1].place}`);
          }
          break;
        }
        case 'chart':
          suggestions.push('Show table view');
          suggestions.push('Filter to magnitude 5+');
          break;
        case 'detail': {
          const q = currentView.data;
          suggestions.push(`Flag this earthquake`);
          const similar = EARTHQUAKES
            .filter(other => other.id !== q.id)
            .sort((a, b) =>
              Math.abs(a.magnitude - q.magnitude) - Math.abs(b.magnitude - q.magnitude)
            );
          if (similar.length) {
            suggestions.push(`Compare with ${similar[0].place}`);
          }
          break;
        }
        case 'comparison': {
          const [q1, q2] = currentView.data;
          const stronger = q1.magnitude > q2.magnitude ? q1 : q2;
          suggestions.push(`Show detail for ${stronger.place}`);
          suggestions.push(`Flag ${stronger.place}`);
          break;
        }
      }

      return suggestions.slice(0, 2);
    }

    function renderFollowupSuggestions() {
      clearFollowupSuggestions();
      const suggestions = getFollowupSuggestions();
      if (!suggestions.length) return;

      const container = document.createElement('div');
      container.className = 'followup-suggestions';
      container.id = 'followup-suggestions';

      suggestions.forEach(text => {
        const btn = document.createElement('button');
        btn.className = 'suggestion-chip followup-chip';
        btn.textContent = text;
        btn.addEventListener('click', () => {
          sendMessage({ prompt: text });
        });
        container.appendChild(btn);
      });

      chatMessages.appendChild(container);
    }

    function clearFollowupSuggestions() {
      const existing = document.getElementById('followup-suggestions');
      if (existing) existing.remove();
    }

    /* ── Dynamic tools ── */

    function getContextualTools() {
      const tools = [];
      if (flaggedQuakes.size > 0) {
        tools.push({
          name: 'review_flags',
          title: 'Review Flags',
          description: `Show all ${flaggedQuakes.size} currently flagged earthquakes with their notes and magnitude.`,
          readOnlyHint: true,
          idempotentHint: true,
          destructiveHint: false,
          openWorldHint: false,
          schema: { type: 'object', properties: {} },
          exec: async () => {
            const flagged = [...flaggedQuakes.keys()]
              .map(id => EARTHQUAKES.find(q => q.id === id))
              .filter(Boolean);
            renderTable(flagged, 'flagged earthquakes');
            return {
              displayed: true,
              count: flagged.length,
              summary: `Showing ${flagged.length} flagged earthquake(s).`,
              earthquakes: flagged.map(q => ({
                place: q.place,
                note: flaggedQuakes.get(q.id).note,
                magnitude: q.magnitude
              }))
            };
          }
        });
        tools.push({
          name: 'clear_all_flags',
          title: 'Clear All Flags',
          description: `Remove all ${flaggedQuakes.size} earthquake flags. This action cannot be undone.`,
          readOnlyHint: false,
          idempotentHint: true,
          destructiveHint: true,
          openWorldHint: false,
          schema: { type: 'object', properties: {} },
          exec: async (input, client) => {
            const count = flaggedQuakes.size;
            const confirmed = await client.requestUserInteraction(() =>
              showConfirmDialog(`Clear all ${count} flags`, { flags: [...flaggedQuakes.keys()] })
            );
            if (!confirmed) return { summary: 'User cancelled.' };
            flaggedQuakes.clear();
            persistFlags();
            refreshCurrentView();
            syncTools();
            return { summary: `Cleared ${count} flag(s).` };
          }
        });
      }
      return tools;
    }

    function getActiveTools() {
      const tools = TOOL_DEFS.map(t => {
        if (t.name === 'compare_earthquakes') {
          const visible = (currentView.type === 'table' && currentView.data) ? currentView.data : EARTHQUAKES;
          const places = visible.slice(0, 50).map(q => q.place);
          return {
            ...t,
            schema: {
              ...t.schema,
              properties: {
                earthquake1: { ...t.schema.properties.earthquake1, enum: places },
                earthquake2: { ...t.schema.properties.earthquake2, enum: places }
              }
            }
          };
        }
        return t;
      });
      return [...tools, ...getContextualTools()];
    }

    function getPageContext() {
      const parts = [];
      switch (currentView.type) {
        case 'table':
          parts.push('Table');
          if (currentView.data) parts.push(`${currentView.data.length} earthquakes`);
          break;
        case 'chart': parts.push('Chart'); break;
        case 'detail':
          if (currentView.data) parts.push(`Detail: ${currentView.data.place}`);
          break;
        case 'comparison':
          if (currentView.data) parts.push(`${currentView.data[0].place} vs ${currentView.data[1].place}`);
          break;
      }
      if (currentView.filters?.min_magnitude) parts.push(`mag ${currentView.filters.min_magnitude}+`);
      if (currentView.filters?.time_range) parts.push(`last ${currentView.filters.time_range}`);
      if (currentView.filters?.felt) parts.push('felt');
      if (flaggedQuakes.size > 0) parts.push(`${flaggedQuakes.size} flagged`);
      return parts;
    }

    function syncTools() {
      const tools = getActiveTools();
      const currentNames = new Set(tools.map(t => t.name));
      const newNames = toolsInitialized
        ? new Set([...currentNames].filter(n => !previousToolNames.has(n)))
        : new Set();

      previousToolNames = currentNames;
      renderToolsPanel(tools, newNames);
      toolsInitialized = true;
    }

    /* ── Tools panel ── */

    function renderToolsPanel(tools, newNames = new Set()) {
      const inner = document.getElementById('tools-panel-inner');
      const toggle = document.getElementById('tools-toggle');
      const panel = document.getElementById('tools-panel');
      const collapsed = panel.dataset.collapsed === 'true';
      toggle.innerHTML = `${collapsed ? '&#9660;' : '&#9650;'} ${tools.length} tools`;

      inner.innerHTML = tools.map(t => {
        const badges = [];
        if (t.readOnlyHint) badges.push('<span class="annotation-badge read-only">read-only</span>');
        if (t.idempotentHint) badges.push('<span class="annotation-badge idempotent">idempotent</span>');
        if (t.destructiveHint) badges.push('<span class="annotation-badge destructive">destructive</span>');
        if (!t.openWorldHint) badges.push('<span class="annotation-badge closed-world">closed-world</span>');

        const isNew = newNames.has(t.name);
        const quakeEnum = Object.entries(t.schema.properties || {})
          .find(([k, v]) => v.enum && (k === 'earthquake1' || k === 'earthquake2'));
        const paramsHtml = quakeEnum
          ? `<div class="tool-item-params">${quakeEnum[1].enum.length} earthquakes available</div>`
          : '';
        const desc = t.description.split('.')[0] + '.';

        return `
          <div class="tool-item${isNew ? ' new' : ''}">
            <div class="tool-item-name">${t.name}</div>
            <div class="tool-item-badges">${badges.join('')}</div>
            <div class="tool-item-desc">${desc}</div>
            ${paramsHtml}
          </div>
        `;
      }).join('');
    }

    function toggleToolsPanel() {
      const panel = document.getElementById('tools-panel');
      const toggle = document.getElementById('tools-toggle');
      const collapsed = panel.dataset.collapsed === 'true';
      panel.dataset.collapsed = collapsed ? 'false' : 'true';
      toggle.setAttribute('aria-expanded', collapsed ? 'true' : 'false');
      const tools = getActiveTools();
      toggle.innerHTML = `${collapsed ? '&#9650;' : '&#9660;'} ${tools.length} tools`;
    }

    document.getElementById('tools-toggle').addEventListener('click', toggleToolsPanel);

    /* ── Shared tool definitions ── */

    const TOOL_DEFS = [
      {
        name: 'filter_earthquakes',
        title: 'Filter Earthquakes',
        description: 'Filter and display earthquakes on the page. Renders a table showing matching earthquakes with magnitude, depth, time, and felt reports. The user can then click any row to see full details.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            min_magnitude: { type: 'number', description: 'Minimum magnitude threshold' },
            search: { type: 'string', description: 'Search by place name (partial match)' },
            time_range: { type: 'string', enum: ['24h', '7d', '30d'], description: 'Filter by time range' }
          }
        },
        exec: async (input) => {
          const filtered = filterData(input);
          const parts = [];
          if (input.min_magnitude) parts.push(`magnitude ${input.min_magnitude}+`);
          if (input.search) parts.push(`matching "${input.search}"`);
          if (input.time_range) parts.push(`last ${input.time_range}`);
          const label = parts.length ? parts.join(', ') : 'all earthquakes';
          renderTable(filtered, label, { min_magnitude: input.min_magnitude, time_range: input.time_range });
          return { displayed: true, count: filtered.length, summary: `Rendered ${filtered.length} earthquakes (${label}). User can now see the table and click any row for details.` };
        }
      },
      {
        name: 'show_earthquake_detail',
        title: 'Earthquake Detail',
        description: 'Display a detailed card for a specific earthquake, showing magnitude, depth, significance, felt reports, tsunami warning, and coordinates. Renders visually on the page.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            place: { type: 'string', description: 'Earthquake place name (partial match supported). Picks the strongest match if ambiguous.' }
          },
          required: ['place']
        },
        exec: async (input) => {
          const matches = EARTHQUAKES.filter(q => matchPlace(q, input.place));
          if (matches.length === 0) return { displayed: false, summary: `No earthquake found matching "${input.place}".` };
          const quake = matches.sort((a, b) => b.magnitude - a.magnitude)[0];
          renderDetail(quake);
          const tier = severityTier(quake.magnitude);
          return { displayed: true, summary: `Showing ${quake.place} — ${tier} (M${fmt(quake.magnitude)}), depth ${fmt(quake.depth)}km, significance ${quake.significance}.` };
        }
      },
      {
        name: 'compare_earthquakes',
        title: 'Compare Earthquakes',
        description: 'Display a side-by-side comparison table of two earthquakes across key metrics: magnitude, depth, significance, felt reports, and tsunami warning.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            earthquake1: { type: 'string', description: 'First earthquake place name (partial match)' },
            earthquake2: { type: 'string', description: 'Second earthquake place name (partial match)' }
          },
          required: ['earthquake1', 'earthquake2']
        },
        exec: async (input) => {
          const matches1 = EARTHQUAKES.filter(q => matchPlace(q, input.earthquake1));
          const matches2 = EARTHQUAKES.filter(q => matchPlace(q, input.earthquake2));
          if (!matches1.length) return { displayed: false, summary: `No earthquake found matching "${input.earthquake1}".` };
          if (!matches2.length) return { displayed: false, summary: `No earthquake found matching "${input.earthquake2}".` };
          const q1 = matches1.sort((a, b) => b.magnitude - a.magnitude)[0];
          const q2 = matches2.sort((a, b) => b.magnitude - a.magnitude)[0];
          renderComparison(q1, q2);
          return { displayed: true, summary: `Comparing ${q1.place} (M${fmt(q1.magnitude)}) vs ${q2.place} (M${fmt(q2.magnitude)}).` };
        }
      },
      {
        name: 'render_chart',
        title: 'Render Chart',
        description: 'Render an Apache ECharts visualization. Generate a full ECharts option object with the appropriate chart type (bar, line, pie, scatter, radar, etc.) based on the data. Use the data available from previous tool calls. Colors should use the palette: ["#38bdf8", "#22c55e", "#f59e0b", "#ef4444", "#a78bfa", "#ec4899"].',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            option: {
              type: 'object',
              description: 'Full ECharts option object (series, xAxis, yAxis, tooltip, legend, etc.)'
            },
            label: {
              type: 'string',
              description: 'Short description shown above the chart'
            }
          },
          required: ['option', 'label']
        },
        exec: async (input) => {
          renderEChart(input.option, input.label);
          return { displayed: true, summary: `Chart rendered: ${input.label}` };
        }
      },
      {
        name: 'summarize_data',
        title: 'Summarize Data',
        description: 'Compute aggregate statistics for the earthquake dataset. Returns numerical summaries (count, max magnitude, average magnitude, average depth, most active region) without rendering any visualization.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            min_magnitude: { type: 'number', description: 'Only include earthquakes at or above this magnitude' }
          }
        },
        exec: async (input) => {
          const data = input.min_magnitude != null
            ? EARTHQUAKES.filter(q => q.magnitude >= input.min_magnitude)
            : EARTHQUAKES;
          if (data.length === 0) return { summary: 'No earthquakes match the given criteria.' };

          const avg = (fn) => data.reduce((s, q) => s + fn(q), 0) / data.length;
          const avgMag = avg(q => q.magnitude);
          const avgDepth = avg(q => q.depth);
          const maxMag = Math.max(...data.map(q => q.magnitude));
          const strongest = data.find(q => q.magnitude === maxMag);

          const regionCounts = {};
          data.forEach(q => {
            regionCounts[q.region] = (regionCounts[q.region] || 0) + 1;
          });
          const mostActiveRegion = Object.entries(regionCounts).sort((a, b) => b[1] - a[1])[0];

          const scope = input.min_magnitude != null ? `magnitude ${input.min_magnitude}+` : 'all earthquakes';
          return {
            scope,
            count: data.length,
            maxMagnitude: maxMag,
            avgMagnitude: +avgMag.toFixed(2),
            avgDepth: +avgDepth.toFixed(1),
            strongestQuake: { place: strongest.place, magnitude: strongest.magnitude },
            mostActiveRegion: mostActiveRegion ? { region: mostActiveRegion[0], count: mostActiveRegion[1] } : null,
            summary: `${data.length} earthquakes (${scope}): max magnitude ${maxMag}, avg magnitude ${avgMag.toFixed(1)}, avg depth ${avgDepth.toFixed(0)}km. Strongest: ${strongest.place} (M${maxMag}). Most active region: ${mostActiveRegion ? mostActiveRegion[0] + ' (' + mostActiveRegion[1] + ')' : 'N/A'}.`
          };
        }
      },
      {
        name: 'flag_earthquake',
        title: 'Flag Earthquake',
        description: 'Flag or unflag an earthquake with a note. Flagged earthquakes display an amber indicator dot in tables and detail views. Use this to mark earthquakes that warrant attention.',
        readOnlyHint: true,
        idempotentHint: false,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            place: { type: 'string', description: 'Earthquake place name (partial match supported)' },
            note: { type: 'string', description: 'Reason for flagging (displayed on detail card)' },
            unflag: { type: 'boolean', description: 'Set to true to remove the flag' }
          },
          required: ['place']
        },
        exec: async (input, client) => {
          const matches = EARTHQUAKES.filter(q => matchPlace(q, input.place));
          if (!matches.length) return { summary: `No earthquake found matching "${input.place}".` };
          const quake = matches.sort((a, b) => b.magnitude - a.magnitude)[0];

          if (input.unflag) {
            const previousFlag = flaggedQuakes.get(quake.id);
            flaggedQuakes.delete(quake.id);
            persistFlags();
            refreshCurrentView();
            showToast('Flag removed', () => {
              flaggedQuakes.set(quake.id, previousFlag || { note: 'Flagged for review', timestamp: Date.now() });
              persistFlags();
              refreshCurrentView();
            });
            return { summary: `Removed flag from ${quake.place}.` };
          }

          let note = input.note;
          if (!note) {
            note = await client.requestUserInteraction(() =>
              showPromptDialog(`Add a note for flagging ${quake.place} (optional)`)
            );
          }

          const flagData = { note: note || 'Flagged for review', timestamp: Date.now() };
          flaggedQuakes.set(quake.id, flagData);
          persistFlags();
          refreshCurrentView();
          showToast('Earthquake flagged', () => {
            flaggedQuakes.delete(quake.id);
            persistFlags();
            refreshCurrentView();
          });
          return { summary: `Flagged ${quake.place}: "${flagData.note}".` };
        }
      },
      {
        name: 'export_flagged',
        title: 'Export Flagged',
        description: 'Download a CSV file of all currently flagged earthquakes with their flag notes and key metrics. Produces a file download.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {}
        },
        exec: async () => {
          if (flaggedQuakes.size === 0) return { summary: 'No earthquakes are currently flagged.' };

          const headers = ['Place', 'Magnitude', 'Depth', 'Significance', 'Felt', 'Tsunami', 'Time', 'Flag Note', 'Flagged At'];
          const rows = [...flaggedQuakes.entries()].map(([id, flag]) => {
            const q = EARTHQUAKES.find(q => q.id === id);
            return [q.place, q.magnitude, q.depth, q.significance, q.felt, q.tsunami, new Date(q.time).toISOString(), flag.note, new Date(flag.timestamp).toISOString()];
          });

          const csv = [headers, ...rows].map(r => r.map(v => `"${v}"`).join(',')).join('\n');
          const blob = new Blob([csv], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'flagged-earthquakes.csv';
          a.click();
          URL.revokeObjectURL(url);

          return { summary: `Exported ${flaggedQuakes.size} flagged earthquake(s) as CSV.` };
        }
      }
    ];

    /* ── Button controls (mirror tool functionality) ── */

    document.querySelectorAll('.chip[data-filter]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');

        const filter = btn.dataset.filter;
        if (filter === 'all') {
          renderTable(EARTHQUAKES);
        } else if (filter === 'mag5') {
          const filtered = filterData({ min_magnitude: 5 });
          renderTable(filtered, 'magnitude 5+', { min_magnitude: 5 });
        } else if (filter === 'mag3') {
          const filtered = filterData({ min_magnitude: 3 });
          renderTable(filtered, 'magnitude 3+', { min_magnitude: 3 });
        } else if (filter === 'felt') {
          const filtered = filterData({ felt: true });
          renderTable(filtered, 'felt earthquakes', { felt: true });
        } else if (filter === 'recent') {
          const filtered = filterData({ time_range: '24h' });
          renderTable(filtered, 'last 24 hours', { time_range: '24h' });
        }
      });
    });

    document.querySelectorAll('.chip[data-view]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');

        const view = btn.dataset.view;
        if (view === 'chart') {
          const tiers = { minor: 0, moderate: 0, strong: 0, major: 0 };
          EARTHQUAKES.forEach(q => tiers[severityTier(q.magnitude)]++);
          renderEChart({
            tooltip: { trigger: 'axis' },
            xAxis: { type: 'category', data: ['Minor', 'Moderate', 'Strong', 'Major'] },
            yAxis: { type: 'value' },
            series: [{ type: 'bar', data: [
              { value: tiers.minor, itemStyle: { color: '#22c55e' } },
              { value: tiers.moderate, itemStyle: { color: '#f59e0b' } },
              { value: tiers.strong, itemStyle: { color: '#ef4444' } },
              { value: tiers.major, itemStyle: { color: '#ef4444' } }
            ] }]
          }, 'Magnitude distribution across all earthquakes');
        }
      });
    });

    /* ── Theme toggle ── */

    function applyTheme(pref) {
      localStorage.setItem('webmcp-theme', pref);
      const resolved = pref === 'system'
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
        : pref;
      document.documentElement.dataset.theme = resolved;
      const meta = document.querySelector('meta[name="theme-color"]');
      if (meta) meta.content = resolved === 'light' ? '#eef1f7' : '#0f1117';
      document.querySelectorAll('.theme-opt').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.theme === pref);
      });
    }

    document.querySelectorAll('.theme-opt').forEach(btn => {
      btn.addEventListener('click', () => applyTheme(btn.dataset.theme));
    });

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      if (localStorage.getItem('webmcp-theme') === 'system') applyTheme('system');
    });

    applyTheme(localStorage.getItem('webmcp-theme') || 'light');

    /* ── Settings popover ── */

    const settingsBtn = document.getElementById('settings-btn');
    const settingsPopover = document.getElementById('settings-popover');

    settingsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const open = !settingsPopover.hidden;
      settingsPopover.hidden = open;
      settingsBtn.setAttribute('aria-expanded', String(!open));
    });

    document.addEventListener('click', (e) => {
      if (!settingsPopover.hidden && !settingsPopover.contains(e.target) && e.target !== settingsBtn) {
        settingsPopover.hidden = true;
        settingsBtn.setAttribute('aria-expanded', 'false');
      }
    });

    /* ── Chat panel ── */

    const LOCAL_PROXY_URL = 'http://127.0.0.1:7337/claude';
    const GITHUB_CLIENT_ID = 'Ov23lioKDt8Os7hdiSEh';
    const CORS_PROXY_URL = 'https://cors-proxy.jonasneves.workers.dev';
    const OAUTH_CALLBACK_ORIGIN = 'https://neevs.io';
    const GITHUB_API_URL = 'https://models.github.ai/inference/chat/completions';

    let currentProvider = 'anthropic';
    let githubAuth = JSON.parse(localStorage.getItem('webmcp-gh-auth') || 'null');
    let ghMessages = [];

    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const chatAbort = document.getElementById('chat-abort');
    const apiKeyInput = document.getElementById('api-key');
    const modelSelect = document.getElementById('model-select');
    const localOption = modelSelect.querySelector('option[value="local:claude"]');

    const SYSTEM_PROMPT_BASE = `You are embedded in a WebMCP proof-of-concept that monitors recent earthquake activity from USGS data. Your tools render visuals (tables, charts, detail cards, comparisons) directly on the page — the user already sees the full result. You only receive a brief summary.

Rules:
- 1-2 sentences max after a tool call. Never redescribe what the visualization already shows.
- Call tools eagerly. If the user asks to see data, call the tool — don't narrate what you're about to do.
- End with a short follow-up suggestion (one line) so the user knows what else they can explore.
- No markdown formatting — this renders as plain text in a chat bubble.
- No greetings, filler, or preamble.
- You can flag earthquakes to mark them for attention. Use flag_earthquake when the user wants to mark, note, or bookmark an earthquake.
- You can compare two earthquakes side-by-side. Use compare_earthquakes when the user wants to see differences.
- Use summarize_data to compute aggregate statistics before writing analysis. This tool returns numbers without rendering — use the data to write insights.
- Use export_flagged to download a CSV of all flagged earthquakes when the user wants to export or save their flags.
- Use render_chart to display Apache ECharts visualizations. Generate a full ECharts option object choosing the best chart type (bar, line, pie, scatter, radar, etc.) for the data. Use the color palette: ["#38bdf8", "#22c55e", "#f59e0b", "#ef4444", "#a78bfa", "#ec4899"]. The theme already sets backgroundColor to transparent.
- Your available tools change dynamically based on page state. When earthquakes are flagged, review_flags and clear_all_flags become available. Tool schemas also adapt — compare_earthquakes only lists currently visible earthquakes.
- When the user gives a short or ambiguous input (like "flag" or "compare"), infer the target from the current view context below. If viewing a detail card, act on that earthquake. If viewing a filtered table, act on visible earthquakes.`;

    function getSystemPrompt() {
      const lines = [SYSTEM_PROMPT_BASE, '', 'Current page state:'];
      switch (currentView.type) {
        case 'table': {
          const data = currentView.data || EARTHQUAKES;
          lines.push(`- Viewing: table of ${data.length} earthquakes`);
          const places = data.slice(0, 8).map(q => `${q.place} (M${fmt(q.magnitude)})`);
          lines.push(`- Visible: ${places.join(', ')}${data.length > 8 ? ` (+${data.length - 8} more)` : ''}`);
          break;
        }
        case 'detail':
          if (currentView.data) {
            const q = currentView.data;
            lines.push(`- Viewing: detail card for ${q.place} (M${fmt(q.magnitude)}, depth ${fmt(q.depth)}km)`);
          }
          break;
        case 'chart':
          lines.push('- Viewing: magnitude distribution chart');
          break;
        case 'comparison':
          if (currentView.data) {
            lines.push(`- Viewing: comparison of ${currentView.data[0].place} vs ${currentView.data[1].place}`);
          }
          break;
      }
      if (currentView.filters?.min_magnitude) lines.push(`- Filtered by: magnitude ${currentView.filters.min_magnitude}+`);
      if (currentView.filters?.time_range) lines.push(`- Filtered by: last ${currentView.filters.time_range}`);
      if (currentView.filters?.felt) lines.push(`- Filtered by: felt earthquakes only`);
      if (flaggedQuakes.size > 0) {
        const flaggedPlaces = [...flaggedQuakes.keys()].map(id => {
          const q = EARTHQUAKES.find(q => q.id === id);
          return q ? q.place : id;
        });
        lines.push(`- Flagged earthquakes (${flaggedQuakes.size}): ${flaggedPlaces.join(', ')}`);
      }
      return lines.join('\n');
    }

    function getClaudeTools() {
      return getActiveTools().map(t => ({ name: t.name, description: t.description, input_schema: t.schema }));
    }

    function getOpenAITools() {
      return getActiveTools().map(t => ({
        type: 'function',
        function: { name: t.name, description: t.description, parameters: t.schema || { type: 'object', properties: {} } }
      }));
    }

    let conversationMessages = [];
    let chatBusy = false;
    let abortController = null;

    // Restore API key: config.json > localStorage
    apiKeyInput.value = localStorage.getItem('webmcp-api-key') || '';

    fetch('config.json').then(r => r.ok ? r.json() : null).then(cfg => {
      if (cfg?.apiKey && !apiKeyInput.value) {
        apiKeyInput.value = cfg.apiKey;
        localStorage.setItem('webmcp-api-key', cfg.apiKey);
      }
    }).catch(() => {});

    async function checkLocalProxy() {
      try {
        const res = await fetch(LOCAL_PROXY_URL, { method: 'OPTIONS', signal: AbortSignal.timeout(800) });
        return res.status === 204;
      } catch {
        return false;
      }
    }

    function applyProviderUI() {
      const isLocal = currentProvider === 'local';
      const isGitHub = currentProvider === 'github';
      const claudeBar = document.getElementById('chat-claude-bar');
      if (claudeBar) claudeBar.hidden = isLocal || isGitHub;
      updateGitHubAuthBar();
      const notice = document.getElementById('github-notice');
      notice.hidden = !isGitHub || !!localStorage.getItem('webmcp-github-notice-dismissed');
      updateModelLabel();
    }

    checkLocalProxy().then(running => {
      if (localOption) localOption.hidden = !running;
      const savedModel = localStorage.getItem('webmcp-model') || 'anthropic:claude-haiku-4-5-20251001';
      const fallback = (!running && savedModel === 'local:claude') ? 'anthropic:claude-haiku-4-5-20251001' : savedModel;
      modelSelect.value = fallback;
      currentProvider = fallback.split(':')[0];
      applyProviderUI();
    });

    modelSelect.addEventListener('change', () => {
      currentProvider = modelSelect.value.split(':')[0];
      localStorage.setItem('webmcp-model', modelSelect.value);
      applyProviderUI();
      conversationMessages = [];
      ghMessages = [];
      chatMessages.innerHTML = '';
      renderQuickActions();
    });

    apiKeyInput.addEventListener('input', () => localStorage.setItem('webmcp-api-key', apiKeyInput.value));

    const keySaveBtn = document.getElementById('key-save');
    if (keySaveBtn) {
      keySaveBtn.addEventListener('click', () => {
        localStorage.setItem('webmcp-api-key', apiKeyInput.value);
      });
    }

    document.getElementById('github-notice-dismiss').addEventListener('click', () => {
      localStorage.setItem('webmcp-github-notice-dismissed', '1');
      document.getElementById('github-notice').hidden = true;
    });

    // Chat reset
    document.getElementById('chat-clear').addEventListener('click', () => {
      conversationMessages = [];
      ghMessages = [];
      chatMessages.innerHTML = '';
      renderQuickActions();
    });

    /* ── GitHub OAuth ── */

    async function exchangeGitHubToken(code, redirectUri) {
      const res = await fetch(`${CORS_PROXY_URL}/token`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ client_id: GITHUB_CLIENT_ID, code, redirect_uri: redirectUri }),
      });
      const data = await res.json();
      if (data.error || !data.access_token) {
        throw new Error(data.error_description || data.error || 'Token exchange failed');
      }
      let username = data.username;
      if (!username) {
        const userRes = await fetch('https://api.github.com/user', {
          headers: { Authorization: `Bearer ${data.access_token}`, Accept: 'application/vnd.github+json' },
        });
        if (userRes.ok) username = (await userRes.json()).login;
      }
      return { token: data.access_token, username: username || '' };
    }

    async function connectGitHub() {
      const redirectUri = OAUTH_CALLBACK_ORIGIN + '/';
      const authUrl = new URL('https://github.com/login/oauth/authorize');
      authUrl.searchParams.set('client_id', GITHUB_CLIENT_ID);
      authUrl.searchParams.set('redirect_uri', redirectUri);
      authUrl.searchParams.set('state', crypto.randomUUID());
      authUrl.searchParams.set('scope', 'read:user');

      const width = 500, height = 600;
      const left = window.screenX + (window.innerWidth - width) / 2;
      const top = window.screenY + (window.innerHeight - height) / 2;

      return new Promise((resolve, reject) => {
        const popup = window.open(
          authUrl.toString(), 'github-oauth',
          `width=${width},height=${height},left=${left},top=${top},popup=yes`
        );
        if (!popup) { reject(new Error('Popup blocked — allow popups for this site')); return; }

        const handleMessage = async (event) => {
          if (event.origin !== OAUTH_CALLBACK_ORIGIN) return;
          const { type, code, error } = event.data || {};
          if (type !== 'oauth-callback') return;
          window.removeEventListener('message', handleMessage);
          clearInterval(pollTimer);
          if (error) { reject(new Error(error)); return; }
          if (!code) { reject(new Error('No code received')); return; }
          try { resolve(await exchangeGitHubToken(code, redirectUri)); } catch (err) { reject(err); }
        };

        window.addEventListener('message', handleMessage);
        const pollTimer = setInterval(() => {
          if (popup.closed) {
            clearInterval(pollTimer);
            window.removeEventListener('message', handleMessage);
            reject(new Error('OAuth flow cancelled'));
          }
        }, 500);
      });
    }

    function updateGitHubAuthBar() {
      const bar = document.getElementById('github-auth-bar');
      if (!bar) return;
      bar.innerHTML = '';
      if (currentProvider !== 'github') return;

      if (githubAuth) {
        const label = document.createElement('span');
        label.className = 'github-user-label';
        label.textContent = `@${githubAuth.username}`;
        const disconnectBtn = document.createElement('button');
        disconnectBtn.className = 'github-disconnect-btn';
        disconnectBtn.textContent = 'Disconnect';
        disconnectBtn.addEventListener('click', () => {
          githubAuth = null;
          localStorage.removeItem('webmcp-gh-auth');
          conversationMessages = [];
          ghMessages = [];
          chatMessages.innerHTML = '';
          renderQuickActions();
          updateGitHubAuthBar();
        });
        bar.append(label, disconnectBtn);
      } else {
        const connectBtn = document.createElement('button');
        connectBtn.className = 'github-connect-btn';
        connectBtn.textContent = 'Connect GitHub';
        connectBtn.addEventListener('click', async () => {
          connectBtn.textContent = 'Connecting\u2026';
          connectBtn.disabled = true;
          try {
            githubAuth = await connectGitHub();
            localStorage.setItem('webmcp-gh-auth', JSON.stringify(githubAuth));
            updateGitHubAuthBar();
          } catch (err) {
            if (err.message !== 'OAuth flow cancelled') appendMessage('error', err.message);
            connectBtn.textContent = 'Connect GitHub';
            connectBtn.disabled = false;
          }
        });
        bar.appendChild(connectBtn);
      }
    }

    // Auto-resize textarea
    chatInput.addEventListener('input', () => {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    });

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    chatSend.addEventListener('click', () => {
      sendMessage();
    });

    chatAbort.addEventListener('click', () => {
      if (abortController) abortController.abort();
    });

    function renderMarkdown(text) {
      return DOMPurify.sanitize(marked.parse(text));
    }

    function appendMessage(type, content) {
      const empty = chatMessages.querySelector('.chat-empty');
      if (empty) empty.remove();

      const el = document.createElement('div');
      el.className = `msg msg-${type}`;
      if (type === 'assistant') {
        el.innerHTML = renderMarkdown(content);
      } else {
        el.textContent = content;
      }
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return el;
    }

    function appendToolMsg(toolName, args, result, isError) {
      const empty = chatMessages.querySelector('.chat-empty');
      if (empty) empty.remove();

      const el = document.createElement('div');
      el.className = 'msg-tool-card' + (isError ? ' error' : '');

      const header = document.createElement('div');
      header.className = 'msg-tool-header';

      const status = document.createElement('span');
      status.className = 'msg-tool-status ' + (isError ? 'error' : 'success');
      status.textContent = isError ? '\u2717' : '\u2713';

      const label = document.createElement('span');
      label.className = 'msg-tool-label';
      const resultStr = typeof result === 'string' ? result : '';
      const summary = resultStr.length > 50 ? resultStr.slice(0, 50) + '...' : resultStr;
      const nameStrong = document.createElement('strong');
      nameStrong.className = 'msg-tool-name';
      nameStrong.textContent = toolName;
      label.append(nameStrong, summary ? ' \u2014 ' + summary : '');

      const chevron = document.createElement('span');
      chevron.className = 'msg-tool-chevron';
      chevron.textContent = '\u25BE';

      header.append(status, label, chevron);
      el.appendChild(header);

      const body = document.createElement('div');
      body.className = 'msg-tool-body';

      const argsEl = document.createElement('div');
      argsEl.className = 'msg-tool-args';
      argsEl.textContent = JSON.stringify(args, null, 2);
      body.appendChild(argsEl);

      if (resultStr) {
        const resultEl = document.createElement('div');
        resultEl.className = 'msg-tool-result';
        resultEl.textContent = '\u2192 ' + resultStr;
        body.appendChild(resultEl);
      }

      el.appendChild(body);

      header.addEventListener('click', () => {
        el.classList.toggle('expanded');
      });

      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function appendDivider(text) {
      const el = document.createElement('div');
      el.className = 'chat-divider';
      el.textContent = text;
      chatMessages.appendChild(el);
    }

    function showSpinner() {
      const el = document.createElement('div');
      el.className = 'chat-spinner';
      el.id = 'chat-spinner';
      el.innerHTML = '<span></span><span></span><span></span>';
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function hideSpinner() {
      const s = document.getElementById('chat-spinner');
      if (s) s.remove();
    }

    function setInputEnabled(enabled) {
      chatBusy = !enabled;
      chatInput.disabled = !enabled;
      chatSend.hidden = !enabled;
      chatAbort.hidden = enabled;
    }

    async function sendMessage(opts = {}) {
      const text = opts.prompt || chatInput.value.trim();
      const displayText = opts.display || text;
      if (!text || chatBusy) return;

      if (currentProvider === 'github') {
        if (!githubAuth?.token) {
          appendMessage('error', 'Connect your GitHub account above.');
          return;
        }
      } else if (currentProvider !== 'local') {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          appendMessage('error', 'Enter your Anthropic API key above.');
          return;
        }
      }

      const quickActions = document.getElementById('quick-actions');
      if (quickActions) quickActions.remove();
      clearFollowupSuggestions();

      appendMessage('user', displayText);
      chatInput.value = '';
      chatInput.style.height = 'auto';

      if (currentProvider === 'github') {
        ghMessages.push({ role: 'user', content: text });
      } else {
        conversationMessages.push({ role: 'user', content: text });
      }
      abortController = new AbortController();
      setInputEnabled(false);
      showSpinner();

      const apiKey = currentProvider === 'local' ? null : apiKeyInput.value.trim();
      await runConversation(apiKey, abortController.signal);

      abortController = null;
      setInputEnabled(true);
      chatInput.focus();
    }

    /* ── Streaming API ── */

    async function streamClaudeAPI(apiKey, messages, signal, proxyUrl = null) {
      const url = proxyUrl || 'https://api.anthropic.com/v1/messages';
      const headers = { 'Content-Type': 'application/json' };
      if (!proxyUrl) {
        headers['x-api-key'] = apiKey;
        headers['anthropic-version'] = '2023-06-01';
        headers['anthropic-dangerous-direct-browser-access'] = 'true';
      }
      const res = await fetch(url, {
        method: 'POST',
        signal,
        headers,
        body: JSON.stringify({
          model: modelSelect.value.split(':').slice(1).join(':'),
          max_tokens: 1024,
          system: getSystemPrompt(),
          messages,
          tools: getClaudeTools(),
          stream: true
        })
      });

      if (!res.ok) {
        const body = await res.text();
        throw new Error(`API ${res.status}: ${body.slice(0, 200)}`);
      }

      return res.body;
    }

    async function* readStreamLines(body) {
      const reader = body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() ?? '';
          for (const line of lines) yield line;
        }
      } finally {
        reader.releaseLock();
      }
    }

    async function* parseSSEStream(body) {
      let currentEvent = null;
      for await (const line of readStreamLines(body)) {
        if (line.startsWith('event: ')) {
          currentEvent = line.slice(7).trim();
        } else if (line.startsWith('data: ') && currentEvent) {
          try { yield { event: currentEvent, data: JSON.parse(line.slice(6)) }; } catch {}
          currentEvent = null;
        }
      }
    }

    async function* parseOpenAIStream(body) {
      for await (const line of readStreamLines(body)) {
        if (!line.startsWith('data: ')) continue;
        const payload = line.slice(6).trim();
        if (payload === '[DONE]') return;
        try { yield JSON.parse(payload); } catch {}
      }
    }

    async function runConversationGitHub(signal) {
      const token = githubAuth?.token;
      const modelName = modelSelect.value.split(':').slice(1).join(':');
      while (true) {
        let body;
        try {
          const res = await fetch(GITHUB_API_URL, {
            method: 'POST',
            signal,
            headers: { 'content-type': 'application/json', 'authorization': `Bearer ${token}` },
            body: JSON.stringify({
              model: modelName,
              messages: [{ role: 'system', content: getSystemPrompt() }, ...ghMessages],
              tools: getOpenAITools(),
              tool_choice: 'auto',
              max_completion_tokens: 1024,
              stream: true
            })
          });
          if (!res.ok) {
            hideSpinner();
            const txt = await res.text();
            appendMessage('error', `GitHub API ${res.status}: ${txt.slice(0, 200)}`);
            return;
          }
          body = res.body;
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', err.message);
          return;
        }

        let currentTextEl = null;
        let currentTextContent = '';
        let rafId = 0;
        const tcMap = {};

        try {
          for await (const chunk of parseOpenAIStream(body)) {
            const delta = chunk.choices?.[0]?.delta;
            if (!delta) continue;

            if (delta.content) {
              if (!currentTextEl) {
                hideSpinner();
                currentTextContent = '';
                currentTextEl = appendMessage('assistant', '');
              }
              currentTextContent += delta.content;
              if (!rafId) {
                rafId = requestAnimationFrame(() => {
                  rafId = 0;
                  if (currentTextEl) {
                    currentTextEl.innerHTML = renderMarkdown(currentTextContent);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                  }
                });
              }
            }

            if (delta.tool_calls) {
              for (const tc of delta.tool_calls) {
                const entry = tcMap[tc.index] ?? (tcMap[tc.index] = { id: '', name: '', arguments: '' });
                if (tc.id) entry.id = tc.id;
                if (tc.function?.name) entry.name += tc.function.name;
                if (tc.function?.arguments) entry.arguments += tc.function.arguments;
              }
            }
          }
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', 'Stream interrupted: ' + err.message);
          return;
        }

        if (rafId) { cancelAnimationFrame(rafId); if (currentTextEl) currentTextEl.innerHTML = renderMarkdown(currentTextContent); }

        const toolCalls = Object.values(tcMap);
        const assistantMsg = { role: 'assistant', content: currentTextContent || null };
        if (toolCalls.length) {
          assistantMsg.tool_calls = toolCalls.map(tc => ({
            id: tc.id, type: 'function', function: { name: tc.name, arguments: tc.arguments }
          }));
        }
        ghMessages.push(assistantMsg);

        if (toolCalls.length === 0) {
          hideSpinner();
          renderFollowupSuggestions();
          return;
        }

        const client = { requestUserInteraction: (cb) => cb() };
        for (const tc of toolCalls) {
          let args;
          try { args = JSON.parse(tc.arguments || '{}'); } catch { args = {}; }
          const def = getActiveTools().find(t => t.name === tc.name);
          let result;
          if (def) {
            if (!def.readOnlyHint) {
              const confirmed = await showConfirmDialog(def.title, args);
              if (!confirmed) {
                result = { summary: `User declined: ${def.title}` };
                appendToolMsg(tc.name, args, result.summary, true);
                ghMessages.push({ role: 'tool', tool_call_id: tc.id, content: JSON.stringify(result) });
                continue;
              }
            }
            result = await def.exec(args, client);
            appendToolMsg(tc.name, args, result.summary);
            if (result.displayed) { scrollDisplayIntoView(); appendDivider(getPageContext().join(' \u00b7 ')); }
          } else {
            result = { error: `Unknown tool: ${tc.name}` };
            appendToolMsg(tc.name, args, result.error, true);
          }
          ghMessages.push({ role: 'tool', tool_call_id: tc.id, content: JSON.stringify(result) });
        }
        showSpinner();
      }
    }

    async function runConversation(apiKey, signal) {
      if (currentProvider === 'github') return runConversationGitHub(signal);

      const proxyUrl = currentProvider === 'local' ? LOCAL_PROXY_URL : null;
      while (true) {
        let body;
        try {
          body = await streamClaudeAPI(apiKey, conversationMessages, signal, proxyUrl);
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', err.message);
          return;
        }

        const contentBlocks = [];
        let currentTextEl = null;
        let currentTextContent = '';
        let currentToolInput = '';
        let currentBlockType = null;
        let mdRenderPending = 0;

        try {
          for await (const { event, data } of parseSSEStream(body)) {
            switch (event) {
              case 'content_block_start': {
                const block = data.content_block;
                currentBlockType = block.type;
                if (block.type === 'text') {
                  hideSpinner();
                  currentTextContent = block.text || '';
                  currentTextEl = appendMessage('assistant', currentTextContent);
                } else if (block.type === 'tool_use') {
                  contentBlocks.push({ type: 'tool_use', id: block.id, name: block.name, input: {} });
                  currentToolInput = '';
                }
                break;
              }

              case 'content_block_delta': {
                if (data.delta.type === 'text_delta') {
                  currentTextContent += data.delta.text;
                  if (currentTextEl) {
                    if (!mdRenderPending) {
                      mdRenderPending = requestAnimationFrame(() => {
                        mdRenderPending = 0;
                        if (currentTextEl) {
                          currentTextEl.innerHTML = renderMarkdown(currentTextContent);
                        }
                      });
                    }
                  }
                } else if (data.delta.type === 'input_json_delta') {
                  currentToolInput += data.delta.partial_json;
                }
                break;
              }

              case 'content_block_stop': {
                if (currentBlockType === 'text' && currentTextContent) {
                  if (mdRenderPending) { cancelAnimationFrame(mdRenderPending); mdRenderPending = 0; }
                  if (currentTextEl) currentTextEl.innerHTML = renderMarkdown(currentTextContent);
                  contentBlocks.push({ type: 'text', text: currentTextContent });
                  currentTextEl = null;
                  currentTextContent = '';
                } else if (currentBlockType === 'tool_use') {
                  const toolBlock = contentBlocks[contentBlocks.length - 1];
                  try {
                    toolBlock.input = currentToolInput ? JSON.parse(currentToolInput) : {};
                  } catch {
                    toolBlock.input = {};
                  }
                  currentToolInput = '';
                }
                currentBlockType = null;
                break;
              }

              case 'message_delta':
                break;
            }
          }
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', 'Stream interrupted: ' + err.message);
          return;
        }

        // Add the full assistant message to conversation history
        conversationMessages.push({ role: 'assistant', content: contentBlocks });

        // Check for tool use
        const toolUses = contentBlocks.filter(b => b.type === 'tool_use');
        if (toolUses.length === 0) {
          hideSpinner();
          renderFollowupSuggestions();
          return;
        }

        // Execute tools and gather results
        const client = {
          requestUserInteraction: (callback) => callback()
        };
        const toolResults = [];
        for (const tu of toolUses) {
          const def = getActiveTools().find(t => t.name === tu.name);
          let result;
          if (def) {
            if (!def.readOnlyHint) {
              const confirmed = await showConfirmDialog(def.title, tu.input);
              if (!confirmed) {
                result = { summary: `User declined: ${def.title}` };
                appendToolMsg(tu.name, tu.input, result.summary, true);
                toolResults.push({ type: 'tool_result', tool_use_id: tu.id, content: JSON.stringify(result) });
                continue;
              }
            }
            result = await def.exec(tu.input, client);
            appendToolMsg(tu.name, tu.input, result.summary);
            if (result.displayed) {
              scrollDisplayIntoView();
              appendDivider(getPageContext().join(' \u00b7 '));
            }
          } else {
            result = { error: `Unknown tool: ${tu.name}` };
            appendToolMsg(tu.name, tu.input, result.error, true);
          }
          toolResults.push({
            type: 'tool_result',
            tool_use_id: tu.id,
            content: JSON.stringify(result)
          });
        }

        conversationMessages.push({ role: 'user', content: toolResults });
        showSpinner();
      }
    }

    /* ── Init ── */

    async function init() {
      renderSkeleton();

      try {
        const res = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const geojson = await res.json();

        EARTHQUAKES = geojson.features.map(feature => ({
          id: feature.id,
          place: feature.properties.place || 'Unknown',
          magnitude: feature.properties.mag || 0,
          depth: feature.geometry.coordinates[2] || 0,
          time: feature.properties.time,
          type: feature.properties.type || 'earthquake',
          status: feature.properties.status || 'automatic',
          tsunami: feature.properties.tsunami === 1,
          felt: feature.properties.felt || 0,
          significance: feature.properties.sig || 0,
          lat: feature.geometry.coordinates[1],
          lon: feature.geometry.coordinates[0],
          region: extractRegion(feature.properties.place)
        })).sort((a, b) => b.time - a.time);
      } catch (err) {
        display.innerHTML = `<p class="msg-error">Failed to load earthquake data: ${err.message}</p>`;
        return;
      }

      loadFlags();

      if (!decodeHashToView()) {
        renderTable(EARTHQUAKES);
      }

      renderQuickActions();
    }

    init();
  </script>
</body>
</html>
