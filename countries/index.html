<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noindex, nofollow">
  <meta name="theme-color" content="#0f172a">
  <title>WebMCP PoC — World Countries</title>
  <style>
    :root {
      --bg: #0f172a;
      --surface: #1e293b;
      --surface-alt: #334155;
      --border: #475569;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --accent: #38bdf8;
      --accent-dim: #0c4a6e;
      --size-small: #22c55e;
      --size-med: #f59e0b;
      --size-large: #ef4444;
      --flag: #f59e0b;
      --radius-sm: 6px;
      --radius: 10px;
      --radius-lg: 14px;
      --font: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --mono: ui-monospace, 'SF Mono', SFMono-Regular, Menlo, monospace;
      --text-xs: 0.6875rem;
      --text-sm: 0.8125rem;
      --text-base: 0.9375rem;
      --text-lg: 1.125rem;
      --text-xl: 1.375rem;
      --text-2xl: 1.75rem;
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 16px;
      --space-lg: 24px;
      --space-xl: 32px;
      --space-2xl: 48px;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.4);
      --shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
      --ease: cubic-bezier(0.4, 0, 0.2, 1);
      --duration: 150ms;
      --duration-slow: 300ms;
    }

    @media (prefers-reduced-motion: reduce) {
      * { transition: none !important; animation: none !important; }
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    body {
      font-family: var(--font);
      font-size: var(--text-base);
      -webkit-font-smoothing: antialiased;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      height: 100dvh;
      display: flex;
      overflow: hidden;
    }

    .main-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-md) var(--space-lg);
      border-bottom: 1px solid var(--border);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    header h1 {
      font-size: var(--text-lg);
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    /* Tools panel */
    .tools-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-slow) var(--ease), border-color var(--duration-slow) var(--ease);
      border-bottom: 1px solid transparent;
    }

    .tools-panel[data-collapsed="false"] {
      max-height: 600px;
      border-bottom-color: var(--border);
    }

    .tools-panel-inner {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      padding: var(--space-md) var(--space-lg);
    }

    .tools-toggle {
      min-height: 44px;
      padding: 0 12px;
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--text-muted);
      background: none;
      border: none;
      cursor: pointer;
      transition: color var(--duration) var(--ease);
    }

    .tools-toggle:hover { color: var(--text); }

    .tool-item {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 12px var(--space-md);
      flex: 1 1 280px;
      max-width: 400px;
      box-shadow: var(--shadow-sm);
    }

    .tool-item-name {
      font-family: var(--mono);
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--accent);
      margin-bottom: var(--space-xs);
    }

    .tool-item-badges {
      display: flex;
      gap: 6px;
      margin-bottom: 6px;
    }

    .annotation-badge {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      padding: 2px var(--space-sm);
      border-radius: 100px;
    }

    .annotation-badge.read-only { background: #052e16; color: var(--size-small); }
    .annotation-badge.idempotent { background: #0c4a6e; color: var(--accent); }
    .annotation-badge.destructive { background: #450a0a; color: var(--size-large); }
    .annotation-badge.closed-world { background: #451a03; color: var(--size-med); }

    .tool-item-desc {
      font-size: var(--text-xs);
      color: var(--text-muted);
      line-height: 1.5;
    }

    .tool-item.new {
      border: 1px solid var(--accent);
    }

    .tool-item-params {
      font-size: var(--text-xs);
      color: var(--accent);
      margin-top: var(--space-xs);
      font-family: var(--mono);
    }

    @media (max-width: 900px) {
      body { flex-direction: column; }
      .chat-panel { border-left: none; border-top: 1px solid var(--border); max-height: 50dvh; width: 100%; }
    }

    main { padding: var(--space-lg); overflow-y: auto; flex: 1; min-height: 0; }

    .controls {
      display: flex;
      gap: var(--space-sm);
      margin-bottom: var(--space-lg);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      mask-image: linear-gradient(to right, black calc(100% - 32px), transparent);
      -webkit-mask-image: linear-gradient(to right, black calc(100% - 32px), transparent);
      padding-right: var(--space-xl);
    }

    .controls::-webkit-scrollbar { display: none; }

    .controls.at-end {
      mask-image: none;
      -webkit-mask-image: none;
      padding-right: 0;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      min-height: 44px;
      padding: 0 var(--space-md);
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--text-muted);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 100px;
      cursor: pointer;
      text-decoration: none;
      white-space: nowrap;
      flex-shrink: 0;
      transition: background var(--duration) var(--ease), color var(--duration) var(--ease), border-color var(--duration) var(--ease);
    }

    .chip:hover { background: var(--surface-alt); color: var(--text); }
    .chip.active { background: var(--accent-dim); color: var(--accent); border-color: var(--accent); }

    .chip-separator {
      width: 1px;
      height: 28px;
      background: var(--border);
      align-self: center;
      flex-shrink: 0;
    }

    #display { min-height: 200px; }

    .empty-state {
      padding: var(--space-2xl) var(--space-lg);
      text-align: center;
      color: var(--text-muted);
      font-size: var(--text-sm);
    }

    /* Loading skeleton */
    @keyframes shimmer {
      0% { background-position: -400px 0; }
      100% { background-position: 400px 0; }
    }

    .loading-skeleton {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .skeleton-row {
      height: 44px;
      border-radius: var(--radius);
      background: linear-gradient(90deg, var(--surface) 25%, var(--surface-alt) 50%, var(--surface) 75%);
      background-size: 800px 44px;
      animation: shimmer 1.5s infinite linear;
    }

    /* Table view */
    .table-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .country-table {
      width: 100%;
      border-collapse: collapse;
      font-size: var(--text-sm);
      min-width: 640px;
    }

    .country-table th,
    .compare-table th {
      text-align: left;
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
    }

    .country-table th {
      padding: 10px 12px;
      white-space: nowrap;
    }

    .country-table td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--surface-alt);
      white-space: nowrap;
    }

    .country-table tbody tr {
      cursor: pointer;
      transition: background var(--duration) var(--ease);
    }

    .country-table tbody tr:hover { background: var(--surface); }
    .country-table tbody tr:focus-visible { outline: 2px solid var(--accent); outline-offset: -2px; }

    .country-name-cell {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .size-badge {
      display: inline-block;
      padding: 2px 10px;
      font-size: var(--text-xs);
      font-weight: 600;
      border-radius: 100px;
      letter-spacing: 0.04em;
    }

    .size-badge.small { background: #052e16; color: var(--size-small); }
    .size-badge.medium { background: #451a03; color: var(--size-med); }
    .size-badge.large { background: #450a0a; color: var(--size-large); }

    /* Flag dot */
    .flag-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--flag);
      flex-shrink: 0;
    }

    .flag-note {
      padding: var(--space-sm) var(--space-lg) 0;
      font-size: var(--text-sm);
      color: var(--flag);
      font-style: italic;
    }

    /* Comparison view */
    .compare-table {
      width: 100%;
      max-width: 640px;
      border-collapse: collapse;
      font-size: var(--text-sm);
    }

    .compare-table th {
      padding: 10px var(--space-md);
    }

    .compare-table td {
      padding: 12px var(--space-md);
      border-bottom: 1px solid var(--surface-alt);
    }

    .compare-metric {
      color: var(--text-muted);
      font-size: var(--text-sm);
    }

    .compare-value {
      font-variant-numeric: tabular-nums;
      font-weight: 500;
    }

    /* Detail view */
    .detail-card {
      max-width: 640px;
      background: var(--surface);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow);
    }

    .detail-header {
      padding: 20px var(--space-lg);
      border-bottom: 1px solid var(--surface-alt);
    }

    .detail-header h2 {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: var(--text-xl);
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: var(--space-xs);
    }

    .detail-meta {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }

    .detail-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1px;
      background: var(--surface-alt);
    }

    .detail-cell {
      padding: var(--space-md) var(--space-lg);
      background: var(--surface);
    }

    .detail-cell-label {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: var(--space-xs);
    }

    .detail-cell-value {
      font-size: var(--text-lg);
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
    }

    .detail-cell-value-text {
      font-size: var(--text-sm);
      font-weight: 500;
      line-height: 1.4;
      word-break: break-word;
      white-space: normal;
    }

    .detail-suffix {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }

    .view-label {
      font-size: var(--text-sm);
      color: var(--text-muted);
      margin-bottom: var(--space-md);
    }

    .chart-container {
      width: 100%;
      min-height: 400px;
    }

    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      min-height: 44px;
      padding: 0 var(--space-md);
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--accent);
      background: none;
      border: 1px solid var(--accent-dim);
      border-radius: var(--radius);
      cursor: pointer;
      margin-bottom: var(--space-md);
    }

    .back-btn:hover { background: var(--accent-dim); }

    /* Summary grid */
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-md);
    }

    .summary-card {
      background: var(--surface);
      border-radius: var(--radius-lg);
      padding: 20px var(--space-lg);
      box-shadow: var(--shadow-sm);
    }

    .summary-card-value {
      font-size: var(--text-2xl);
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
      margin-bottom: var(--space-xs);
    }

    .summary-card-label {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: var(--space-xs);
    }

    .summary-card-meta {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }

    /* Chat panel */
    .chat-panel {
      width: 380px;
      flex-shrink: 0;
      border-left: 1px solid var(--border);
      background: var(--surface);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-utility-bar {
      display: flex;
      justify-content: flex-end;
      gap: var(--space-md);
      padding: var(--space-xs) var(--space-md);
    }

    .chat-utility-btn {
      min-height: 44px;
      padding: 0 var(--space-sm);
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-family: var(--font);
      color: var(--text-muted);
      background: none;
      border: none;
      cursor: pointer;
      transition: color var(--duration) var(--ease);
    }

    .chat-utility-btn:hover { color: var(--text); }

    .api-key-bar {
      display: none;
      gap: var(--space-sm);
      padding: 12px var(--space-md);
      border-bottom: 1px solid var(--surface-alt);
    }

    .api-key-bar.visible {
      display: flex;
    }

    .api-key-bar input {
      flex: 1;
      min-height: 36px;
      padding: 0 12px;
      font-size: var(--text-sm);
      font-family: var(--mono);
      color: var(--text);
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    .api-key-bar input::placeholder { color: var(--text-muted); }
    .api-key-bar input:focus { outline: 2px solid var(--accent); outline-offset: -1px; }

    .api-key-toggle {
      min-width: 44px;
      min-height: 36px;
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--text-muted);
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      cursor: pointer;
    }

    .api-key-toggle:hover { color: var(--text); }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    .chat-messages > :first-child { margin-top: auto; }

    .chat-empty {
      text-align: center;
      color: var(--text-muted);
      font-size: var(--text-sm);
      padding: var(--space-lg) var(--space-md);
      line-height: 1.6;
    }

    .msg {
      padding: 10px 14px;
      border-radius: var(--radius-lg);
      font-size: var(--text-sm);
      line-height: 1.5;
      word-break: break-word;
    }

    .msg-user {
      align-self: flex-end;
      max-width: 85%;
      background: var(--accent-dim);
      color: var(--accent);
      border-bottom-right-radius: 4px;
    }

    .msg-assistant {
      background: var(--surface-alt);
      color: var(--text);
      border-bottom-left-radius: 4px;
    }

    .msg-assistant p { margin: 0; }
    .msg-assistant p + p { margin-top: var(--space-sm); }
    .msg-assistant ul, .msg-assistant ol { margin: var(--space-xs) 0; padding-left: 20px; }
    .msg-assistant li + li { margin-top: 2px; }
    .msg-assistant strong { color: var(--text); }
    .msg-assistant code {
      font-family: var(--mono);
      font-size: 0.9em;
      padding: 1px 5px;
      background: var(--bg);
      border-radius: 4px;
    }
    .msg-assistant pre {
      margin: 6px 0;
      padding: var(--space-sm) 10px;
      background: var(--bg);
      border-radius: var(--radius);
      overflow-x: auto;
    }
    .msg-assistant pre code { padding: 0; background: none; }

    .msg-tool-name { color: var(--accent); font-weight: 600; }

    /* Chat divider */
    .chat-divider {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      padding: var(--space-xs) 0;
    }

    .chat-divider::before,
    .chat-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--surface-alt);
    }

    /* Tool call cards */
    .msg-tool-card {
      align-self: stretch;
      background: var(--surface);
      border: 1px solid var(--surface-alt);
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      font-family: var(--mono);
      font-size: var(--text-xs);
      color: var(--text-muted);
      overflow: hidden;
    }

    .msg-tool-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: 6px 12px;
      cursor: pointer;
      transition: background var(--duration) var(--ease);
    }

    .msg-tool-header:hover { background: var(--surface-alt); }

    .msg-tool-status { flex-shrink: 0; }
    .msg-tool-status.success { color: var(--size-small); }
    .msg-tool-status.error { color: var(--size-large); }

    .msg-tool-label {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .msg-tool-chevron {
      flex-shrink: 0;
      font-size: var(--text-xs);
      color: var(--text-muted);
      transition: transform var(--duration) var(--ease);
    }

    .msg-tool-card.expanded .msg-tool-chevron { transform: rotate(180deg); }

    .msg-tool-body {
      display: none;
      padding: 0 12px var(--space-sm);
      font-size: var(--text-xs);
      line-height: 1.6;
      border-top: 1px solid var(--surface-alt);
    }

    .msg-tool-card.expanded .msg-tool-body { display: block; padding-top: var(--space-sm); }

    .msg-tool-args {
      color: var(--text-muted);
      word-break: break-word;
      white-space: pre-wrap;
    }

    .msg-tool-result {
      color: var(--size-small);
      margin-top: var(--space-xs);
      word-break: break-word;
      white-space: pre-wrap;
    }

    .msg-tool-card.error .msg-tool-result { color: var(--size-large); }

    .msg-error {
      padding: var(--space-sm) 14px;
      font-size: var(--text-xs);
      color: var(--size-large);
      background: #450a0a;
      border-radius: var(--radius);
    }

    .chat-input-area {
      display: flex;
      gap: var(--space-sm);
      padding: 12px var(--space-md);
      border-top: 1px solid var(--surface-alt);
    }

    .chat-input-area textarea {
      flex: 1;
      min-height: 44px;
      max-height: 120px;
      padding: 10px 12px;
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--text);
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      resize: none;
      line-height: 1.4;
    }

    .chat-input-area textarea::placeholder { color: var(--text-muted); }
    .chat-input-area textarea:focus { outline: 2px solid var(--accent); outline-offset: -1px; }

    .chat-send {
      min-width: 44px;
      min-height: 44px;
      font-size: var(--text-lg);
      font-family: var(--font);
      color: var(--bg);
      background: var(--accent);
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      transition: opacity var(--duration) var(--ease);
    }

    .chat-send:disabled { opacity: 0.4; cursor: default; }
    .chat-send:not(:disabled):hover { opacity: 0.85; }

    .chat-send.stop {
      background: var(--size-large);
      font-size: var(--text-sm);
    }

    @keyframes chat-spin {
      to { transform: rotate(360deg); }
    }

    .chat-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--surface-alt);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: chat-spin 0.6s linear infinite;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: var(--space-sm);
    }

    .summary-count {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }

    /* Suggestion chips (quick actions + follow-ups) */
    .followup-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chat-quick-actions {
      display: flex;
      gap: 6px;
      padding: var(--space-xs) var(--space-lg) var(--space-xs) 0;
      overflow-x: auto;
      scrollbar-width: none;
      -webkit-mask-image: linear-gradient(to right, black calc(100% - var(--space-lg)), transparent);
      mask-image: linear-gradient(to right, black calc(100% - var(--space-lg)), transparent);
    }
    .chat-quick-actions::-webkit-scrollbar { display: none; }

    .suggestion-chip {
      min-height: 36px;
      padding: 6px 14px;
      font-size: var(--text-xs);
      font-family: var(--font);
      background: none;
      border: 1px solid var(--surface-alt);
      border-radius: 100px;
      cursor: pointer;
      transition: color var(--duration) var(--ease), border-color var(--duration) var(--ease);
    }

    .quick-action-chip {
      color: var(--accent);
      text-align: left;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .quick-action-chip:hover { color: var(--text); border-color: var(--accent); }

    .followup-chip { color: var(--text-muted); }
    .followup-chip:hover { color: var(--text); border-color: var(--border); }

    /* Toast */
    .toast-container {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
    }

    @keyframes toast-slide-up {
      from { transform: translateY(16px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .toast {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      min-height: 52px;
      padding: 10px var(--space-md);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow-lg);
      animation: toast-slide-up 200ms ease;
      white-space: nowrap;
    }

    .toast-message {
      font-size: var(--text-sm);
      color: var(--text);
    }

    .toast-undo {
      min-height: 44px;
      padding: 0 14px;
      font-size: var(--text-sm);
      font-weight: 600;
      font-family: var(--font);
      color: var(--accent);
      background: none;
      border: 1px solid var(--accent-dim);
      border-radius: var(--radius);
      cursor: pointer;
      transition: background var(--duration) var(--ease);
    }

    .toast-undo:hover { background: var(--accent-dim); }

    @media (max-width: 600px) {
      .toast-container {
        left: 16px;
        right: 16px;
        transform: none;
      }
      .toast { width: 100%; }
    }

    /* Dialogs */
    dialog {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-lg);
      max-width: 400px;
      width: 90%;
      box-shadow: var(--shadow-lg);
      color: var(--text);
    }

    dialog::backdrop { background: rgba(0, 0, 0, 0.6); }

    .dialog-title {
      font-size: var(--text-base);
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: 12px;
    }

    .dialog-tool {
      font-family: var(--mono);
      font-size: var(--text-sm);
      color: var(--accent);
      margin-bottom: var(--space-xs);
    }

    .dialog-args {
      font-family: var(--mono);
      font-size: var(--text-xs);
      color: var(--text-muted);
      background: var(--bg);
      padding: var(--space-sm) 12px;
      border-radius: var(--radius);
      margin-bottom: var(--space-md);
      word-break: break-all;
    }

    .dialog-actions {
      display: flex;
      gap: var(--space-sm);
      justify-content: flex-end;
    }

    .dialog-actions button {
      min-height: 44px;
      padding: 0 20px;
      font-size: var(--text-sm);
      font-family: var(--font);
      border-radius: var(--radius);
      cursor: pointer;
    }

    .btn-cancel {
      color: var(--text-muted);
      background: none;
      border: 1px solid var(--border);
    }

    .btn-cancel:hover { color: var(--text); border-color: var(--text-muted); }

    .btn-confirm {
      color: var(--bg);
      background: var(--accent);
      border: none;
    }

    .btn-confirm:hover { opacity: 0.85; }

    .dialog-input {
      width: 100%;
      padding: 10px 12px;
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--text);
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      margin-bottom: var(--space-md);
    }

    .dialog-input:focus {
      outline: 2px solid var(--accent);
      outline-offset: 0;
      border-color: transparent;
    }

    .chip:active,
    .tools-toggle:active,
    .back-btn:active,
    .chat-send:active,
    .chat-utility-btn:active,
    .api-key-toggle:active,
    .toast-undo:active,
    .suggestion-chip:active,
    .btn-cancel:active,
    .btn-confirm:active,
    .msg-tool-header:active { transform: scale(0.97); }
  </style>
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/marked@15/marked.min.js" as="script">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js" as="script">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js" as="script">
  <script src="https://cdn.jsdelivr.net/npm/marked@15/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
  <div class="main-column">
    <header>
      <div class="header-left">
        <h1>WebMCP PoC</h1>
        <button class="tools-toggle" id="tools-toggle" aria-expanded="false">&#9660; 7 tools</button>
      </div>
    </header>

    <div class="tools-panel" id="tools-panel" data-collapsed="true">
      <div class="tools-panel-inner" id="tools-panel-inner"></div>
    </div>

    <main>
      <nav class="controls" aria-label="Filters">
        <button class="chip active" data-filter="all">All</button>
        <button class="chip" data-filter="Americas">Americas</button>
        <button class="chip" data-filter="Europe">Europe</button>
        <button class="chip" data-filter="Asia">Asia</button>
        <button class="chip" data-filter="Africa">Africa</button>
        <button class="chip" data-filter="Oceania">Oceania</button>
        <div class="chip-separator"></div>
        <button class="chip" data-view="chart">Population Chart</button>
        <button class="chip" data-filter="large">Large Countries Only</button>
      </nav>

      <div id="display"></div>
    </main>
  </div>

  <aside class="chat-panel">
    <div class="api-key-bar">
      <input type="password" id="api-key" placeholder="sk-ant-..." autocomplete="off" spellcheck="false" aria-label="Anthropic API key">
      <button class="api-key-toggle" id="key-toggle" aria-label="Toggle key visibility">Show</button>
    </div>
    <div class="chat-messages" id="chat-messages" aria-live="polite"></div>
    <div class="chat-utility-bar">
      <button class="chat-utility-btn" id="key-edit" aria-label="API key">Key</button>
      <button class="chat-utility-btn" id="chat-reset" aria-label="Clear chat">Clear</button>
    </div>
    <div class="chat-input-area">
      <textarea id="chat-input" placeholder="Ask about countries..." rows="1" aria-label="Chat message"></textarea>
      <button class="chat-send" id="chat-send" aria-label="Send message">&uarr;</button>
    </div>
  </aside>

  <div class="toast-container" id="toast-container" role="status" aria-live="polite"></div>

  <dialog id="confirm-dialog" aria-labelledby="confirm-title">
    <form method="dialog">
      <p class="dialog-title" id="confirm-title">Confirm action</p>
      <p class="dialog-tool" id="confirm-tool"></p>
      <p class="dialog-args" id="confirm-args"></p>
      <div class="dialog-actions">
        <button class="btn-cancel" value="cancel">Cancel</button>
        <button class="btn-confirm" value="confirm">Confirm</button>
      </div>
    </form>
  </dialog>

  <dialog id="prompt-dialog" aria-labelledby="prompt-title">
    <form method="dialog">
      <p class="dialog-title" id="prompt-title"></p>
      <input type="text" class="dialog-input" id="prompt-input" autocomplete="off">
      <div class="dialog-actions">
        <button class="btn-cancel" value="cancel">Skip</button>
        <button class="btn-confirm" value="confirm">Add</button>
      </div>
    </form>
  </dialog>

  <script>
    marked.use({ gfm: true, breaks: true });

    /* ── Dataset ── */

    let COUNTRIES = [];

    /* ── State ── */

    const flaggedCountries = new Map();
    let currentView = { type: 'table', data: null, label: null, filters: null };
    let currentToastTimeout = null;
    let previousToolNames = new Set();
    let toolsInitialized = false;

    /* ── Constants ── */

    const QUICK_ACTIONS = [
      'Show European countries',
      'Compare USA and China',
      'Population by region as a pie chart',
      'Top 10 countries by area as a bar chart',
      'Plot population vs area as scatter'
    ];

    /* ── Utilities ── */

    function sizeTier(population) {
      if (population >= 50000000) return 'large';
      if (population >= 10000000) return 'medium';
      return 'small';
    }

    function matchName(country, query) {
      return country.name.toLowerCase().includes(query.toLowerCase());
    }

    function filterData({ region, subregion, search, size } = {}) {
      return COUNTRIES.filter(c => {
        if (region && c.region !== region) return false;
        if (subregion && c.subregion !== subregion) return false;
        if (size && sizeTier(c.population) !== size) return false;
        if (search && !matchName(c, search)) return false;
        return true;
      });
    }

    function scrollDisplayIntoView() {
      if (window.matchMedia('(max-width: 900px)').matches) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      } else {
        display.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function refreshCurrentView() {
      if (currentView.type === 'table') {
        renderTable(currentView.data || COUNTRIES, currentView.label, currentView.filters);
      } else if (currentView.type === 'chart' && currentView.data) {
        renderEChart(currentView.data, currentView.label);
      } else if (currentView.type === 'detail' && currentView.data) {
        renderDetail(currentView.data);
      } else if (currentView.type === 'comparison' && currentView.data) {
        renderComparison(currentView.data[0], currentView.data[1]);
      }
    }

    /* ── URL State ── */

    function encodeViewToHash() {
      const params = new URLSearchParams();
      params.set('view', currentView.type);
      const f = currentView.filters || {};

      if (currentView.type === 'table') {
        if (f.region) params.set('region', f.region);
        if (f.size) params.set('size', f.size);
      } else if (currentView.type === 'detail' && currentView.data) {
        params.set('name', currentView.data.name);
      } else if (currentView.type === 'comparison' && currentView.data) {
        params.set('c1', currentView.data[0].name);
        params.set('c2', currentView.data[1].name);
      }

      history.replaceState(null, '', '#' + params.toString());
    }

    function decodeHashToView() {
      const hash = location.hash.slice(1);
      if (!hash) return false;

      const params = new URLSearchParams(hash);
      const view = params.get('view');

      if (view === 'table') {
        const region = params.get('region');
        const size = params.get('size');
        if (region) {
          renderTable(filterData({ region }), `countries in ${region}`, { region });
        } else if (size) {
          renderTable(filterData({ size }), `${size} countries`, { size });
        } else {
          renderTable(COUNTRIES);
        }
        return true;
      }

      if (view === 'chart') {
        renderTable(COUNTRIES);
        return true;
      }

      if (view === 'detail') {
        const name = params.get('name');
        const c = COUNTRIES.find(c => c.name === name);
        if (c) { renderDetail(c); return true; }
      }

      if (view === 'comparison') {
        const c1 = COUNTRIES.find(c => c.name === params.get('c1'));
        const c2 = COUNTRIES.find(c => c.name === params.get('c2'));
        if (c1 && c2) { renderComparison(c1, c2); return true; }
      }

      return false;
    }

    window.addEventListener('hashchange', () => {
      if (COUNTRIES.length) decodeHashToView();
    });

    /* ── Rendering ── */

    const display = document.getElementById('display');

    echarts.registerTheme('webmcp', {
      backgroundColor: 'transparent',
      textStyle: { fontFamily: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif" },
      title: { textStyle: { color: '#f1f5f9' } },
      legend: { textStyle: { color: '#94a3b8' } },
      categoryAxis: {
        axisLine: { lineStyle: { color: '#475569' } },
        axisLabel: { color: '#94a3b8' },
        splitLine: { lineStyle: { color: '#1e293b' } }
      },
      valueAxis: {
        axisLine: { lineStyle: { color: '#475569' } },
        axisLabel: { color: '#94a3b8' },
        splitLine: { lineStyle: { color: '#1e293b' } }
      },
      tooltip: {
        backgroundColor: '#1e293b',
        borderColor: '#475569',
        textStyle: { color: '#f1f5f9' }
      }
    });

    let chartInstance = null;

    function renderEChart(option, label) {
      currentView = { type: 'chart', data: option, label, filters: {} };
      if (chartInstance) { chartInstance.dispose(); chartInstance = null; }
      display.innerHTML = `
        <p class="view-label">${label}</p>
        <div id="chart-container" class="chart-container"></div>
      `;
      const container = document.getElementById('chart-container');
      chartInstance = echarts.init(container, 'webmcp');
      chartInstance.setOption(option);
      encodeViewToHash();
      syncTools();
    }

    window.addEventListener('resize', () => {
      if (chartInstance) chartInstance.resize();
    });

    function renderSkeleton() {
      display.innerHTML = `
        <div class="loading-skeleton">
          ${Array.from({ length: 8 }, (_, i) =>
            `<div class="skeleton-row" style="animation-delay: ${i * 80}ms"></div>`
          ).join('')}
        </div>
      `;
    }

    function renderTable(countries, label, filters) {
      currentView = { type: 'table', data: countries, label, filters };
      const summary = label || `${countries.length} countries`;

      if (countries.length === 0) {
        display.innerHTML = `<p class="empty-state">No countries match the current filters.</p>`;
        encodeViewToHash();
        syncTools();
        return;
      }

      display.innerHTML = `
        <div class="summary-row">
          <p class="view-label">Showing ${summary}</p>
          <span class="summary-count">${countries.length} result${countries.length !== 1 ? 's' : ''}</span>
        </div>
        <div class="table-scroll">
        <table class="country-table">
          <thead>
            <tr>
              <th>Country</th>
              <th>Region</th>
              <th>Population</th>
              <th>Area (km&sup2;)</th>
              <th>Capital</th>
            </tr>
          </thead>
          <tbody>
            ${countries.map(c => {
              const isFlagged = flaggedCountries.has(c.name);
              return `
              <tr tabindex="0" data-name="${c.name}">
                <td><span class="country-name-cell">${isFlagged ? '<span class="flag-dot" title="Flagged"></span>' : ''}${c.flag} ${c.name}</span></td>
                <td>${c.region}</td>
                <td>${c.population.toLocaleString()}</td>
                <td>${c.area.toLocaleString()}</td>
                <td>${c.capital}</td>
              </tr>`;
            }).join('')}
          </tbody>
        </table>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderDetail(country) {
      const c = country;
      const tier = sizeTier(c.population);
      const flag = flaggedCountries.get(c.name);
      currentView = { type: 'detail', data: c, label: null, filters: null };

      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <div class="detail-card">
          <div class="detail-header">
            <h2>${flag ? '<span class="flag-dot"></span>' : ''}${c.flag} ${c.name}</h2>
            <p class="detail-meta">${c.region} &middot; ${c.subregion} &middot; ${c.capital}</p>
          </div>
          ${flag ? `<p class="flag-note">${flag.note.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</p>` : ''}
          <div class="detail-grid">
            <div class="detail-cell">
              <div class="detail-cell-label">Population</div>
              <div class="detail-cell-value">${c.population.toLocaleString()}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Area</div>
              <div class="detail-cell-value">${c.area.toLocaleString()}<span class="detail-suffix"> km&sup2;</span></div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Population Density</div>
              <div class="detail-cell-value">${c.populationDensity.toLocaleString()}<span class="detail-suffix"> /km&sup2;</span></div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Languages</div>
              <div class="detail-cell-value detail-cell-value-text">${c.languages}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Currencies</div>
              <div class="detail-cell-value detail-cell-value-text">${c.currencies}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Independent</div>
              <div class="detail-cell-value">${c.independent ? 'Yes' : 'No'}</div>
            </div>
          </div>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderComparison(c1, c2) {
      currentView = { type: 'comparison', data: [c1, c2], label: null, filters: null };

      const metrics = [
        { label: 'Population', key: 'population', format: v => v.toLocaleString() },
        { label: 'Area (km\u00B2)', key: 'area', format: v => v.toLocaleString() },
        { label: 'Population Density', key: 'populationDensity', format: v => v.toLocaleString() + ' /km\u00B2' },
        { label: 'Languages', key: 'languages', format: v => v },
        { label: 'Currencies', key: 'currencies', format: v => v },
        { label: 'Independent', key: 'independent', format: v => v ? 'Yes' : 'No' },
      ];

      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <p class="view-label">Comparing two countries</p>
        <table class="compare-table">
          <thead>
            <tr>
              <th>Metric</th>
              <th>${c1.flag} ${c1.name}</th>
              <th>${c2.flag} ${c2.name}</th>
            </tr>
          </thead>
          <tbody>
            ${metrics.map(m => `
              <tr>
                <td class="compare-metric">${m.label}</td>
                <td class="compare-value">${m.format(c1[m.key])}</td>
                <td class="compare-value">${m.format(c2[m.key])}</td>
              </tr>`).join('')}
          </tbody>
        </table>
      `;
      encodeViewToHash();
      syncTools();
    }

    /* ── Display event delegation ── */

    display.addEventListener('click', (e) => {
      const row = e.target.closest('tr[data-name]');
      if (row) { showDetail(row.dataset.name); return; }
      const backBtn = e.target.closest('.back-btn');
      if (backBtn) renderTable(COUNTRIES);
    });

    display.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      const row = e.target.closest('tr[data-name]');
      if (row) showDetail(row.dataset.name);
    });

    function showDetail(name) {
      const c = COUNTRIES.find(c => c.name === name);
      if (!c) return;
      renderDetail(c);
    }

    /* ── Toast ── */

    function showToast(message, onUndo) {
      dismissToast();

      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'toast';

      const msgSpan = document.createElement('span');
      msgSpan.className = 'toast-message';
      msgSpan.textContent = message;
      toast.appendChild(msgSpan);

      const undoBtn = document.createElement('button');
      undoBtn.className = 'toast-undo';
      undoBtn.textContent = 'Undo';
      undoBtn.addEventListener('click', () => {
        dismissToast();
        onUndo();
      });
      toast.appendChild(undoBtn);

      container.appendChild(toast);
      currentToastTimeout = setTimeout(dismissToast, 5000);
    }

    function dismissToast() {
      if (currentToastTimeout) {
        clearTimeout(currentToastTimeout);
        currentToastTimeout = null;
      }
      document.getElementById('toast-container').innerHTML = '';
    }

    /* ── Persistence ── */

    function persistFlags() {
      const data = [...flaggedCountries.entries()].map(([name, flag]) => ({ name, ...flag }));
      localStorage.setItem('webmcp-country-flags', JSON.stringify(data));
    }

    function loadFlags() {
      try {
        const data = JSON.parse(localStorage.getItem('webmcp-country-flags') || '[]');
        data.forEach(({ name, ...flag }) => flaggedCountries.set(name, flag));
      } catch {}
    }

    /* ── Confirmation dialog ── */

    function showConfirmDialog(toolName, args) {
      const dialog = document.getElementById('confirm-dialog');
      document.getElementById('confirm-tool').textContent = toolName;
      document.getElementById('confirm-args').textContent = JSON.stringify(args, null, 2);
      dialog.returnValue = '';
      dialog.showModal();
      return new Promise(resolve => {
        dialog.addEventListener('close', () => {
          resolve(dialog.returnValue === 'confirm');
        }, { once: true });
      });
    }

    function showPromptDialog(message) {
      const dialog = document.getElementById('prompt-dialog');
      const input = document.getElementById('prompt-input');
      document.getElementById('prompt-title').textContent = message;
      input.value = '';
      dialog.returnValue = '';
      dialog.showModal();
      input.focus();
      function onEnter(e) {
        if (e.key === 'Enter') { e.preventDefault(); dialog.close('confirm'); }
      }
      input.addEventListener('keydown', onEnter);
      return new Promise(resolve => {
        dialog.addEventListener('close', () => {
          input.removeEventListener('keydown', onEnter);
          resolve(dialog.returnValue === 'confirm' ? (input.value || null) : null);
        }, { once: true });
      });
    }

    /* ── Keyboard shortcuts ── */

    document.addEventListener('keydown', (e) => {
      if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey && !e.target.matches('input, textarea')) {
        chatInput.focus();
      }
      if (e.key === 'Escape') {
        const panel = document.getElementById('tools-panel');
        if (panel.dataset.collapsed === 'false') { toggleToolsPanel(); return; }
        dismissToast();
      }
    });

    /* ── Controls scroll fade ── */

    const controlsNav = document.querySelector('.controls');
    function updateScrollFade() {
      const atEnd = controlsNav.scrollLeft + controlsNav.clientWidth >= controlsNav.scrollWidth - 4;
      controlsNav.classList.toggle('at-end', atEnd);
    }
    controlsNav.addEventListener('scroll', updateScrollFade, { passive: true });
    updateScrollFade();

    /* ── Quick actions ── */

    function renderQuickActions() {
      const container = document.createElement('div');
      container.className = 'chat-quick-actions';
      container.id = 'quick-actions';

      QUICK_ACTIONS.forEach(prompt => {
        const btn = document.createElement('button');
        btn.className = 'suggestion-chip quick-action-chip';
        btn.textContent = prompt;
        btn.addEventListener('click', () => {
          sendMessage({ prompt });
        });
        container.appendChild(btn);
      });

      chatMessages.appendChild(container);
    }

    /* ── Follow-up suggestions ── */

    function getFollowupSuggestions() {
      const suggestions = [];

      switch (currentView.type) {
        case 'table': {
          suggestions.push('Show population chart');
          const large = (currentView.data || COUNTRIES)
            .filter(c => sizeTier(c.population) === 'large')
            .sort((a, b) => b.population - a.population);
          if (large.length >= 2) {
            suggestions.push(`Compare ${large[0].name} and ${large[1].name}`);
          }
          break;
        }
        case 'chart':
          suggestions.push('Show table view');
          suggestions.push('Filter to large countries only');
          break;
        case 'detail': {
          const c = currentView.data;
          suggestions.push(`Flag ${c.name}`);
          const sameRegion = COUNTRIES
            .filter(other => other.name !== c.name && other.region === c.region)
            .sort((a, b) =>
              Math.abs(a.population - c.population) - Math.abs(b.population - c.population)
            );
          if (sameRegion.length) {
            suggestions.push(`Compare with ${sameRegion[0].name}`);
          }
          break;
        }
        case 'comparison': {
          const [c1, c2] = currentView.data;
          const larger = c1.population > c2.population ? c1 : c2;
          suggestions.push(`Show detail for ${larger.name}`);
          suggestions.push(`Flag ${larger.name}`);
          break;
        }
      }

      return suggestions.slice(0, 2);
    }

    function renderFollowupSuggestions() {
      clearFollowupSuggestions();
      const suggestions = getFollowupSuggestions();
      if (!suggestions.length) return;

      const container = document.createElement('div');
      container.className = 'followup-suggestions';
      container.id = 'followup-suggestions';

      suggestions.forEach(text => {
        const btn = document.createElement('button');
        btn.className = 'suggestion-chip followup-chip';
        btn.textContent = text;
        btn.addEventListener('click', () => {
          sendMessage({ prompt: text });
        });
        container.appendChild(btn);
      });

      chatMessages.appendChild(container);
    }

    function clearFollowupSuggestions() {
      const existing = document.getElementById('followup-suggestions');
      if (existing) existing.remove();
    }

    /* ── Dynamic tools ── */

    function getContextualTools() {
      const tools = [];
      if (flaggedCountries.size > 0) {
        tools.push({
          name: 'review_flags',
          title: 'Review Flags',
          description: `Show all ${flaggedCountries.size} currently flagged countries with their notes and region.`,
          readOnlyHint: true,
          idempotentHint: true,
          destructiveHint: false,
          openWorldHint: false,
          schema: { type: 'object', properties: {} },
          exec: async () => {
            const flagged = [...flaggedCountries.keys()]
              .map(name => COUNTRIES.find(c => c.name === name))
              .filter(Boolean);
            renderTable(flagged, 'flagged countries');
            return {
              displayed: true,
              count: flagged.length,
              summary: `Showing ${flagged.length} flagged country(ies).`,
              countries: flagged.map(c => ({
                name: c.name,
                note: flaggedCountries.get(c.name).note,
                region: c.region
              }))
            };
          }
        });
        tools.push({
          name: 'clear_all_flags',
          title: 'Clear All Flags',
          description: `Remove all ${flaggedCountries.size} country flags. This action cannot be undone.`,
          readOnlyHint: false,
          idempotentHint: true,
          destructiveHint: true,
          openWorldHint: false,
          schema: { type: 'object', properties: {} },
          exec: async (input, client) => {
            const count = flaggedCountries.size;
            const confirmed = await client.requestUserInteraction(() =>
              showConfirmDialog(`Clear all ${count} flags`, { flags: [...flaggedCountries.keys()] })
            );
            if (!confirmed) return { summary: 'User cancelled.' };
            flaggedCountries.clear();
            persistFlags();
            refreshCurrentView();
            syncTools();
            return { summary: `Cleared ${count} flag(s).` };
          }
        });
      }
      return tools;
    }

    function getActiveTools() {
      const tools = TOOL_DEFS.map(t => {
        if (t.name === 'compare_countries') {
          const visible = (currentView.type === 'table' && currentView.data) ? currentView.data : COUNTRIES;
          const names = visible.map(c => c.name);
          return {
            ...t,
            schema: {
              ...t.schema,
              properties: {
                country1: { ...t.schema.properties.country1, enum: names },
                country2: { ...t.schema.properties.country2, enum: names }
              }
            }
          };
        }
        return t;
      });
      return [...tools, ...getContextualTools()];
    }

    function getPageContext() {
      const parts = [];
      switch (currentView.type) {
        case 'table':
          parts.push('Table');
          if (currentView.data) parts.push(`${currentView.data.length} countries`);
          break;
        case 'chart': parts.push('Chart'); break;
        case 'detail':
          if (currentView.data) parts.push(`Detail: ${currentView.data.name}`);
          break;
        case 'comparison':
          if (currentView.data) parts.push(`${currentView.data[0].name} vs ${currentView.data[1].name}`);
          break;
      }
      if (currentView.filters?.region) parts.push(currentView.filters.region);
      if (currentView.filters?.size) parts.push(`${currentView.filters.size} countries`);
      if (flaggedCountries.size > 0) parts.push(`${flaggedCountries.size} flagged`);
      return parts;
    }

    function syncTools() {
      const tools = getActiveTools();
      const currentNames = new Set(tools.map(t => t.name));
      const newNames = toolsInitialized
        ? new Set([...currentNames].filter(n => !previousToolNames.has(n)))
        : new Set();

      previousToolNames = currentNames;
      renderToolsPanel(tools, newNames);
      toolsInitialized = true;
    }

    /* ── Tools panel ── */

    function renderToolsPanel(tools, newNames = new Set()) {
      const inner = document.getElementById('tools-panel-inner');
      const toggle = document.getElementById('tools-toggle');
      const panel = document.getElementById('tools-panel');
      const collapsed = panel.dataset.collapsed === 'true';
      toggle.innerHTML = `${collapsed ? '&#9660;' : '&#9650;'} ${tools.length} tools`;

      inner.innerHTML = tools.map(t => {
        const badges = [];
        if (t.readOnlyHint) badges.push('<span class="annotation-badge read-only">read-only</span>');
        if (t.idempotentHint) badges.push('<span class="annotation-badge idempotent">idempotent</span>');
        if (t.destructiveHint) badges.push('<span class="annotation-badge destructive">destructive</span>');
        if (!t.openWorldHint) badges.push('<span class="annotation-badge closed-world">closed-world</span>');

        const isNew = newNames.has(t.name);
        const countryEnum = Object.entries(t.schema.properties || {})
          .find(([k, v]) => v.enum && (k === 'country1' || k === 'country2'));
        const paramsHtml = countryEnum
          ? `<div class="tool-item-params">${countryEnum[1].enum.length} countries available</div>`
          : '';
        const desc = t.description.split('.')[0] + '.';

        return `
          <div class="tool-item${isNew ? ' new' : ''}">
            <div class="tool-item-name">${t.name}</div>
            <div class="tool-item-badges">${badges.join('')}</div>
            <div class="tool-item-desc">${desc}</div>
            ${paramsHtml}
          </div>
        `;
      }).join('');
    }

    function toggleToolsPanel() {
      const panel = document.getElementById('tools-panel');
      const toggle = document.getElementById('tools-toggle');
      const collapsed = panel.dataset.collapsed === 'true';
      panel.dataset.collapsed = collapsed ? 'false' : 'true';
      toggle.setAttribute('aria-expanded', collapsed ? 'true' : 'false');
      const tools = getActiveTools();
      toggle.innerHTML = `${collapsed ? '&#9650;' : '&#9660;'} ${tools.length} tools`;
    }

    document.getElementById('tools-toggle').addEventListener('click', toggleToolsPanel);

    /* ── Shared tool definitions ── */

    const TOOL_DEFS = [
      {
        name: 'filter_countries',
        title: 'Filter Countries',
        description: 'Filter and display world countries on the page. Renders a table showing matching countries with region, population, area, and capital. The user can then click any row to see full details.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            region: { type: 'string', enum: ['Americas', 'Europe', 'Asia', 'Africa', 'Oceania', 'Antarctic'], description: 'Filter by region' },
            subregion: { type: 'string', description: 'Filter by subregion (e.g. "Western Europe", "South America")' },
            search: { type: 'string', description: 'Search country name (partial match)' }
          }
        },
        exec: async (input) => {
          const filtered = filterData(input);
          const parts = [];
          if (input.region) parts.push(`in ${input.region}`);
          if (input.subregion) parts.push(`in ${input.subregion}`);
          if (input.search) parts.push(`matching "${input.search}"`);
          const label = parts.length ? parts.join(', ') : 'all countries';
          renderTable(filtered, label, { region: input.region });
          return { displayed: true, count: filtered.length, summary: `Rendered ${filtered.length} countries (${label}). User can now see the table and click any row for details.` };
        }
      },
      {
        name: 'show_country_detail',
        title: 'Country Detail',
        description: 'Display a detailed profile card for a specific country, showing population, area, density, languages, currencies, and independence status. Renders visually on the page.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'Country name (partial match supported)' }
          },
          required: ['name']
        },
        exec: async (input) => {
          const country = COUNTRIES.find(c => matchName(c, input.name));
          if (!country) return { displayed: false, summary: `No country found matching "${input.name}".` };
          renderDetail(country);
          return { displayed: true, summary: `Showing ${country.name} (${country.region}) -- population ${country.population.toLocaleString()}, area ${country.area.toLocaleString()} km\u00B2.` };
        }
      },
      {
        name: 'compare_countries',
        title: 'Compare Countries',
        description: 'Display a side-by-side comparison table of two countries across key metrics: population, area, population density, languages, currencies, and independence status.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            country1: { type: 'string', description: 'First country name (partial match)' },
            country2: { type: 'string', description: 'Second country name (partial match)' }
          },
          required: ['country1', 'country2']
        },
        exec: async (input) => {
          const c1 = COUNTRIES.find(c => matchName(c, input.country1));
          const c2 = COUNTRIES.find(c => matchName(c, input.country2));
          if (!c1) return { displayed: false, summary: `No country found matching "${input.country1}".` };
          if (!c2) return { displayed: false, summary: `No country found matching "${input.country2}".` };
          renderComparison(c1, c2);
          return { displayed: true, summary: `Comparing ${c1.name} vs ${c2.name}. Population ${c1.population.toLocaleString()} vs ${c2.population.toLocaleString()}, area ${c1.area.toLocaleString()} vs ${c2.area.toLocaleString()} km\u00B2.` };
        }
      },
      {
        name: 'render_chart',
        title: 'Render Chart',
        description: 'Render an Apache ECharts visualization. Generate a full ECharts option object with the appropriate chart type (bar, line, pie, scatter, radar, etc.) based on the data. Use the data available from previous tool calls. Colors should use the palette: ["#38bdf8", "#22c55e", "#f59e0b", "#ef4444", "#a78bfa", "#ec4899"].',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            option: {
              type: 'object',
              description: 'Full ECharts option object (series, xAxis, yAxis, tooltip, legend, etc.)'
            },
            label: {
              type: 'string',
              description: 'Short description shown above the chart'
            }
          },
          required: ['option', 'label']
        },
        exec: async (input) => {
          renderEChart(input.option, input.label);
          return { displayed: true, summary: `Chart rendered: ${input.label}` };
        }
      },
      {
        name: 'summarize_data',
        title: 'Summarize Data',
        description: 'Compute aggregate statistics for the country dataset. Returns numerical summaries (count, total population, average density, largest, smallest) without rendering any visualization.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            region: { type: 'string', enum: ['Americas', 'Europe', 'Asia', 'Africa', 'Oceania', 'Antarctic'], description: 'Limit summary to a specific region' }
          }
        },
        exec: async (input) => {
          const data = input.region ? filterData({ region: input.region }) : COUNTRIES;
          if (data.length === 0) return { summary: `No countries found for region "${input.region}".` };

          const totalPop = data.reduce((s, c) => s + c.population, 0);
          const totalArea = data.reduce((s, c) => s + c.area, 0);
          const avgDensity = Math.round(data.reduce((s, c) => s + c.populationDensity, 0) / data.length);

          const byPop = [...data].sort((a, b) => b.population - a.population);
          const largest = byPop[0];
          const smallest = byPop[byPop.length - 1];

          const scope = input.region || 'all regions';
          return {
            scope,
            count: data.length,
            totalPopulation: totalPop,
            totalArea: totalArea,
            avgDensity,
            largest: { name: largest.name, population: largest.population },
            smallest: { name: smallest.name, population: smallest.population },
            summary: `${data.length} countries (${scope}): total population ${totalPop.toLocaleString()}, avg density ${avgDensity}/km². Largest: ${largest.name} (${largest.population.toLocaleString()}), smallest: ${smallest.name} (${smallest.population.toLocaleString()}).`
          };
        }
      },
      {
        name: 'flag_country',
        title: 'Flag Country',
        description: 'Flag or unflag a country with a note. Flagged countries display an amber indicator dot in tables and detail views. Use this to mark countries that warrant attention or follow-up.',
        readOnlyHint: true,
        idempotentHint: false,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'Country name (partial match supported)' },
            note: { type: 'string', description: 'Reason for flagging (displayed on detail card)' },
            unflag: { type: 'boolean', description: 'Set to true to remove the flag' }
          },
          required: ['name']
        },
        exec: async (input, client) => {
          const country = COUNTRIES.find(c => matchName(c, input.name));
          if (!country) return { summary: `No country found matching "${input.name}".` };

          if (input.unflag) {
            const previousFlag = flaggedCountries.get(country.name);
            flaggedCountries.delete(country.name);
            persistFlags();
            refreshCurrentView();
            showToast('Flag removed', () => {
              flaggedCountries.set(country.name, previousFlag || { note: 'Flagged for review', timestamp: Date.now() });
              persistFlags();
              refreshCurrentView();
            });
            return { summary: `Removed flag from ${country.name}.` };
          }

          let note = input.note;
          if (!note) {
            note = await client.requestUserInteraction(() =>
              showPromptDialog(`Add a note for flagging ${country.name} (optional)`)
            );
          }

          const flagData = { note: note || 'Flagged for review', timestamp: Date.now() };
          flaggedCountries.set(country.name, flagData);
          persistFlags();
          refreshCurrentView();
          showToast('Country flagged', () => {
            flaggedCountries.delete(country.name);
            persistFlags();
            refreshCurrentView();
          });
          return { summary: `Flagged ${country.name}: "${flagData.note}".` };
        }
      },
      {
        name: 'export_flagged',
        title: 'Export Flagged',
        description: 'Download a CSV file of all currently flagged countries with their flag notes and key metrics. Produces a file download, does not render a visualization.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {}
        },
        exec: async () => {
          if (flaggedCountries.size === 0) return { summary: 'No countries are currently flagged.' };

          const headers = ['Name', 'Region', 'Population', 'Area', 'Density', 'Flag Note', 'Flagged At'];
          const rows = [...flaggedCountries.entries()].map(([name, flag]) => {
            const c = COUNTRIES.find(c => c.name === name);
            return [name, c.region, c.population, c.area, c.populationDensity, flag.note, new Date(flag.timestamp).toISOString()];
          });

          const csv = [headers, ...rows].map(r => r.map(v => `"${v}"`).join(',')).join('\n');
          const blob = new Blob([csv], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'flagged-countries.csv';
          a.click();
          URL.revokeObjectURL(url);

          return { summary: `Exported ${flaggedCountries.size} flagged country(ies) as CSV.` };
        }
      }
    ];

    /* ── Button controls (mirror tool functionality) ── */

    document.querySelectorAll('.chip[data-filter]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');

        const filter = btn.dataset.filter;
        if (filter === 'all') {
          renderTable(COUNTRIES);
        } else if (filter === 'large') {
          const filtered = filterData({ size: 'large' });
          renderTable(filtered, 'large countries (50M+ population)', { size: 'large' });
        } else {
          const filtered = filterData({ region: filter });
          renderTable(filtered, `countries in ${filter}`, { region: filter });
        }
      });
    });

    document.querySelectorAll('.chip[data-view]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');

        const view = btn.dataset.view;
        if (view === 'chart') {
          const regions = {};
          COUNTRIES.forEach(c => { regions[c.region] = (regions[c.region] || 0) + 1; });
          const regionColors = { 'Asia': '#f59e0b', 'Africa': '#fb923c', 'Europe': '#a78bfa', 'Americas': '#38bdf8', 'Oceania': '#22c55e', 'Antarctic': '#94a3b8' };
          const sorted = ['Asia', 'Africa', 'Europe', 'Americas', 'Oceania', 'Antarctic'].filter(r => regions[r]);
          renderEChart({
            tooltip: { trigger: 'axis' },
            xAxis: { type: 'category', data: sorted },
            yAxis: { type: 'value' },
            series: [{ type: 'bar', data: sorted.map(r => ({ value: regions[r], itemStyle: { color: regionColors[r] } })) }]
          }, 'Countries by region');
        }
      });
    });

    /* ── Chat panel ── */

    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const chatReset = document.getElementById('chat-reset');
    const apiKeyInput = document.getElementById('api-key');
    const keyToggle = document.getElementById('key-toggle');

    const SYSTEM_PROMPT_BASE = `You are embedded in a WebMCP proof-of-concept that explores world country data. Your tools render visuals (tables, charts, detail cards, comparisons) directly on the page \u2014 the user already sees the full result. You only receive a brief summary.

Rules:
- 1-2 sentences max after a tool call. Never redescribe what the visualization already shows.
- Call tools eagerly. If the user asks to see data, call the tool \u2014 don't narrate what you're about to do.
- End with a short follow-up suggestion (one line) so the user knows what else they can explore.
- No markdown formatting \u2014 this renders as plain text in a chat bubble.
- No greetings, filler, or preamble.
- You can flag countries to mark them for attention. Use flag_country when the user wants to mark, note, or bookmark a country.
- You can compare two countries side-by-side. Use compare_countries when the user wants to see differences.
- Use summarize_data to compute aggregate statistics before writing analysis. This tool returns numbers without rendering \u2014 use the data to write insights.
- Use export_flagged to download a CSV of all flagged countries when the user wants to export or save their flags.
- Use render_chart to display Apache ECharts visualizations. Generate a full ECharts option object choosing the best chart type (bar, line, pie, scatter, radar, etc.) for the data. Use the color palette: ["#38bdf8", "#22c55e", "#f59e0b", "#ef4444", "#a78bfa", "#ec4899"]. The theme already sets backgroundColor to transparent.
- Your available tools change dynamically based on page state. When countries are flagged, review_flags and clear_all_flags become available. Tool schemas also adapt \u2014 compare_countries only lists currently visible countries.
- When the user gives a short or ambiguous input (like "flag" or "compare"), infer the target from the current view context below. If viewing a detail card, act on that country. If viewing a filtered table, act on visible countries.`;

    function getSystemPrompt() {
      const lines = [SYSTEM_PROMPT_BASE, '', 'Current page state:'];
      switch (currentView.type) {
        case 'table': {
          const data = currentView.data || COUNTRIES;
          lines.push(`- Viewing: table of ${data.length} countries`);
          const names = data.slice(0, 8).map(c => c.name);
          lines.push(`- Visible: ${names.join(', ')}${data.length > 8 ? ` (+${data.length - 8} more)` : ''}`);
          break;
        }
        case 'detail':
          if (currentView.data) {
            const c = currentView.data;
            lines.push(`- Viewing: detail card for ${c.name} (${c.region}, population: ${c.population.toLocaleString()}, area: ${c.area.toLocaleString()} km\u00B2)`);
          }
          break;
        case 'chart':
          lines.push('- Viewing: region distribution chart');
          break;
        case 'comparison':
          if (currentView.data) {
            lines.push(`- Viewing: comparison of ${currentView.data[0].name} vs ${currentView.data[1].name}`);
          }
          break;
      }
      if (currentView.filters?.region) lines.push(`- Filtered by region: ${currentView.filters.region}`);
      if (currentView.filters?.size) lines.push(`- Filtered by size: ${currentView.filters.size}`);
      if (flaggedCountries.size > 0) {
        lines.push(`- Flagged countries (${flaggedCountries.size}): ${[...flaggedCountries.keys()].join(', ')}`);
      }
      return lines.join('\n');
    }

    function getClaudeTools() {
      return getActiveTools().map(t => ({ name: t.name, description: t.description, input_schema: t.schema }));
    }

    let conversationMessages = [];
    let chatBusy = false;
    let abortController = null;

    // Restore API key: config.json > localStorage
    const apiKeyBar = document.querySelector('.api-key-bar');
    const keyEditBtn = document.getElementById('key-edit');

    apiKeyInput.value = localStorage.getItem('webmcp-api-key') || '';

    fetch('config.json').then(r => r.ok ? r.json() : null).then(cfg => {
      if (cfg?.apiKey && !apiKeyInput.value) {
        apiKeyInput.value = cfg.apiKey;
        localStorage.setItem('webmcp-api-key', cfg.apiKey);
      }
    }).catch(() => {}).finally(() => {
      if (!apiKeyInput.value) apiKeyBar.classList.add('visible');
    });

    apiKeyInput.addEventListener('input', () => localStorage.setItem('webmcp-api-key', apiKeyInput.value));

    keyEditBtn.addEventListener('click', () => {
      apiKeyBar.classList.toggle('visible');
      if (apiKeyBar.classList.contains('visible')) apiKeyInput.focus();
    });

    keyToggle.addEventListener('click', () => {
      const hidden = apiKeyInput.type === 'password';
      apiKeyInput.type = hidden ? 'text' : 'password';
      keyToggle.textContent = hidden ? 'Hide' : 'Show';
    });

    // Chat reset
    chatReset.addEventListener('click', () => {
      conversationMessages = [];
      chatMessages.innerHTML = '';
      renderQuickActions();
    });

    // Auto-resize textarea
    chatInput.addEventListener('input', () => {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    });

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    chatSend.addEventListener('click', () => {
      if (chatBusy && abortController) {
        abortController.abort();
        return;
      }
      sendMessage();
    });

    function renderMarkdown(text) {
      return DOMPurify.sanitize(marked.parse(text));
    }

    function appendMessage(type, content) {
      const empty = chatMessages.querySelector('.chat-empty');
      if (empty) empty.remove();

      const el = document.createElement('div');
      el.className = `msg msg-${type}`;
      if (type === 'assistant') {
        el.innerHTML = renderMarkdown(content);
      } else {
        el.textContent = content;
      }
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return el;
    }

    function appendToolMsg(toolName, args, result, isError) {
      const empty = chatMessages.querySelector('.chat-empty');
      if (empty) empty.remove();

      const el = document.createElement('div');
      el.className = 'msg-tool-card' + (isError ? ' error' : '');

      const header = document.createElement('div');
      header.className = 'msg-tool-header';

      const status = document.createElement('span');
      status.className = 'msg-tool-status ' + (isError ? 'error' : 'success');
      status.textContent = isError ? '\u2717' : '\u2713';

      const label = document.createElement('span');
      label.className = 'msg-tool-label';
      const resultStr = typeof result === 'string' ? result : '';
      const summary = resultStr.length > 50 ? resultStr.slice(0, 50) + '...' : resultStr;
      const nameStrong = document.createElement('strong');
      nameStrong.className = 'msg-tool-name';
      nameStrong.textContent = toolName;
      label.append(nameStrong, summary ? ' \u2014 ' + summary : '');

      const chevron = document.createElement('span');
      chevron.className = 'msg-tool-chevron';
      chevron.textContent = '\u25BE';

      header.append(status, label, chevron);
      el.appendChild(header);

      const body = document.createElement('div');
      body.className = 'msg-tool-body';

      const argsEl = document.createElement('div');
      argsEl.className = 'msg-tool-args';
      argsEl.textContent = JSON.stringify(args, null, 2);
      body.appendChild(argsEl);

      if (resultStr) {
        const resultEl = document.createElement('div');
        resultEl.className = 'msg-tool-result';
        resultEl.textContent = '\u2192 ' + resultStr;
        body.appendChild(resultEl);
      }

      el.appendChild(body);

      header.addEventListener('click', () => {
        el.classList.toggle('expanded');
      });

      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function appendDivider(text) {
      const el = document.createElement('div');
      el.className = 'chat-divider';
      el.textContent = text;
      chatMessages.appendChild(el);
    }

    function showSpinner() {
      const el = document.createElement('div');
      el.className = 'chat-spinner';
      el.id = 'chat-spinner';
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function hideSpinner() {
      const s = document.getElementById('chat-spinner');
      if (s) s.remove();
    }

    function setInputEnabled(enabled) {
      chatBusy = !enabled;
      chatInput.disabled = !enabled;
      chatSend.disabled = false;
      chatSend.classList.toggle('stop', !enabled);
      chatSend.textContent = enabled ? '\u2191' : '\u25A0';
      chatSend.setAttribute('aria-label', enabled ? 'Send message' : 'Stop generation');
    }

    async function sendMessage(opts = {}) {
      const text = opts.prompt || chatInput.value.trim();
      const displayText = opts.display || text;
      const apiKey = apiKeyInput.value.trim();
      if (!text || chatBusy) return;

      if (!apiKey) {
        appendMessage('error', 'Enter your Anthropic API key above.');
        return;
      }

      const quickActions = document.getElementById('quick-actions');
      if (quickActions) quickActions.remove();
      clearFollowupSuggestions();

      appendMessage('user', displayText);
      chatInput.value = '';
      chatInput.style.height = 'auto';

      conversationMessages.push({ role: 'user', content: text });
      abortController = new AbortController();
      setInputEnabled(false);
      showSpinner();

      await runConversation(apiKey, abortController.signal);

      abortController = null;
      setInputEnabled(true);
      chatInput.focus();
    }

    /* ── Streaming API ── */

    async function streamClaudeAPI(apiKey, messages, signal) {
      const res = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        signal,
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true'
        },
        body: JSON.stringify({
          model: 'claude-haiku-4-5-20251001',
          max_tokens: 1024,
          system: getSystemPrompt(),
          messages,
          tools: getClaudeTools(),
          stream: true
        })
      });

      if (!res.ok) {
        const body = await res.text();
        throw new Error(`API ${res.status}: ${body.slice(0, 200)}`);
      }

      return res.body;
    }

    async function* parseSSEStream(body) {
      const reader = body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });

        const lines = buffer.split('\n');
        buffer = lines.pop();

        let currentEvent = null;
        for (const line of lines) {
          if (line.startsWith('event: ')) {
            currentEvent = line.slice(7).trim();
          } else if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data && currentEvent) {
              try {
                yield { event: currentEvent, data: JSON.parse(data) };
              } catch {}
            }
            currentEvent = null;
          }
        }
      }
    }

    async function runConversation(apiKey, signal) {
      while (true) {
        let body;
        try {
          body = await streamClaudeAPI(apiKey, conversationMessages, signal);
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', err.message);
          return;
        }

        const contentBlocks = [];
        let currentTextEl = null;
        let currentTextContent = '';
        let currentToolInput = '';
        let currentBlockType = null;
        let mdRenderPending = 0;

        try {
          for await (const { event, data } of parseSSEStream(body)) {
            switch (event) {
              case 'content_block_start': {
                const block = data.content_block;
                currentBlockType = block.type;
                if (block.type === 'text') {
                  hideSpinner();
                  currentTextContent = block.text || '';
                  currentTextEl = appendMessage('assistant', currentTextContent);
                } else if (block.type === 'tool_use') {
                  contentBlocks.push({ type: 'tool_use', id: block.id, name: block.name, input: {} });
                  currentToolInput = '';
                }
                break;
              }

              case 'content_block_delta': {
                if (data.delta.type === 'text_delta') {
                  currentTextContent += data.delta.text;
                  if (currentTextEl) {
                    if (!mdRenderPending) {
                      mdRenderPending = requestAnimationFrame(() => {
                        mdRenderPending = 0;
                        if (currentTextEl) {
                          currentTextEl.innerHTML = renderMarkdown(currentTextContent);
                        }
                      });
                    }
                  }
                } else if (data.delta.type === 'input_json_delta') {
                  currentToolInput += data.delta.partial_json;
                }
                break;
              }

              case 'content_block_stop': {
                if (currentBlockType === 'text' && currentTextContent) {
                  if (mdRenderPending) { cancelAnimationFrame(mdRenderPending); mdRenderPending = 0; }
                  if (currentTextEl) currentTextEl.innerHTML = renderMarkdown(currentTextContent);
                  contentBlocks.push({ type: 'text', text: currentTextContent });
                  currentTextEl = null;
                  currentTextContent = '';
                } else if (currentBlockType === 'tool_use') {
                  const toolBlock = contentBlocks[contentBlocks.length - 1];
                  try {
                    toolBlock.input = currentToolInput ? JSON.parse(currentToolInput) : {};
                  } catch {
                    toolBlock.input = {};
                  }
                  currentToolInput = '';
                }
                currentBlockType = null;
                break;
              }

              case 'message_delta':
                break;
            }
          }
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', 'Stream interrupted: ' + err.message);
          return;
        }

        // Add the full assistant message to conversation history
        conversationMessages.push({ role: 'assistant', content: contentBlocks });

        // Check for tool use
        const toolUses = contentBlocks.filter(b => b.type === 'tool_use');
        if (toolUses.length === 0) {
          hideSpinner();
          renderFollowupSuggestions();
          return;
        }

        // Execute tools and gather results
        const client = {
          requestUserInteraction: (callback) => callback()
        };
        const toolResults = [];
        for (const tu of toolUses) {
          const def = getActiveTools().find(t => t.name === tu.name);
          let result;
          if (def) {
            if (!def.readOnlyHint) {
              const confirmed = await showConfirmDialog(def.title, tu.input);
              if (!confirmed) {
                result = { summary: `User declined: ${def.title}` };
                appendToolMsg(tu.name, tu.input, result.summary, true);
                toolResults.push({ type: 'tool_result', tool_use_id: tu.id, content: JSON.stringify(result) });
                continue;
              }
            }
            result = await def.exec(tu.input, client);
            appendToolMsg(tu.name, tu.input, result.summary);
            if (result.displayed) {
              scrollDisplayIntoView();
              appendDivider(getPageContext().join(' \u00b7 '));
            }
          } else {
            result = { error: `Unknown tool: ${tu.name}` };
            appendToolMsg(tu.name, tu.input, result.error, true);
          }
          toolResults.push({
            type: 'tool_result',
            tool_use_id: tu.id,
            content: JSON.stringify(result)
          });
        }

        conversationMessages.push({ role: 'user', content: toolResults });
        showSpinner();
      }
    }

    /* ── Init ── */

    async function init() {
      renderSkeleton();

      try {
        const res = await fetch('https://restcountries.com/v3.1/all?fields=name,population,area,region,subregion,capital,languages,currencies,flag,independent');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const raw = await res.json();

        COUNTRIES = raw.map(country => ({
          name: country.name.common,
          official: country.name.official,
          region: country.region,
          subregion: country.subregion || 'N/A',
          population: country.population,
          area: country.area || 0,
          capital: (country.capital || [])[0] || 'N/A',
          languages: Object.values(country.languages || {}).join(', ') || 'N/A',
          currencies: Object.values(country.currencies || {}).map(c => c.name).join(', ') || 'N/A',
          flag: country.flag || '',
          independent: country.independent,
          populationDensity: country.area ? Math.round(country.population / country.area) : 0
        })).sort((a, b) => b.population - a.population);
      } catch (err) {
        display.innerHTML = `<p class="msg-error">Failed to load country data: ${err.message}</p>`;
        return;
      }

      loadFlags();

      if (!decodeHashToView()) {
        renderTable(COUNTRIES);
      }

      renderQuickActions();
    }

    init();
  </script>
</body>
</html>
