<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="robots" content="noindex, nofollow">
  <meta name="theme-color" content="#e8ebf2">
  <title>WebMCP PoC — World Countries</title>
  <style>
    :root {
      --bg: #e8ebf2;
      --surface: #ffffff;
      --surface-alt: #eef0f7;
      --border: #c8cdd9;
      --text: #111827;
      --text-muted: #64748b;
      --accent: #0d9488;
      --accent-dim: #c8f0eb;
      --size-small: #16a34a;
      --size-med: #d97706;
      --size-large: #dc2626;
      --flag: #d97706;
      --badge-green-bg: #dcfce7;
      --badge-amber-bg: #fef3c7;
      --badge-red-bg: #fee2e2;
      --badge-cyan-bg: #c8f0eb;
      --radius-sm: 6px;
      --radius: 10px;
      --radius-lg: 14px;
      --font: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --mono: ui-monospace, 'SF Mono', SFMono-Regular, Menlo, monospace;
      --text-xs: 0.6875rem;
      --text-sm: 0.8125rem;
      --text-base: 0.9375rem;
      --text-lg: 1.125rem;
      --text-xl: 1.375rem;
      --text-2xl: 1.75rem;
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 16px;
      --space-lg: 24px;
      --space-xl: 32px;
      --space-2xl: 48px;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.06);
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.10), 0 1px 4px rgba(0, 0, 0, 0.05);
      --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.15), 0 4px 8px rgba(0, 0, 0, 0.08);
      --ease: cubic-bezier(0.2, 0.8, 0.2, 1);
      --duration: 150ms;
      --duration-slow: 300ms;
    }

    html[data-theme="dark"] {
      --bg: #0f1117;
      --surface: #1a1d24;
      --surface-alt: #21252d;
      --border: #2d3139;
      --text: #e8eaf0;
      --text-muted: #8b92a5;
      --accent: #2dd4bf;
      --accent-dim: #0f3935;
      --size-small: #22c55e;
      --size-med: #f59e0b;
      --size-large: #ef4444;
      --flag: #f59e0b;
      --badge-green-bg: #052e16;
      --badge-amber-bg: #3d1f00;
      --badge-red-bg: #3d0a0a;
      --badge-cyan-bg: #0f3935;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2);
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.35), 0 1px 4px rgba(0, 0, 0, 0.2);
      --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5), 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    @media (prefers-reduced-motion: reduce) {
      * { transition: none !important; animation: none !important; }
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    :focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    body {
      font-family: var(--font);
      font-size: var(--text-base);
      -webkit-font-smoothing: antialiased;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      height: 100dvh;
      display: flex;
      overflow: hidden;
    }

    .main-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 52px;
      padding: 0 var(--space-lg);
      border-bottom: none;
      background: #111827;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
    }

    html[data-theme="dark"] header {
      background: var(--surface);
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.04);
      border-bottom: 1px solid var(--border);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    header h1 {
      font-size: var(--text-base);
      font-weight: 600;
      letter-spacing: -0.02em;
      color: rgba(255, 255, 255, 0.92);
    }

    html[data-theme="dark"] header h1 { color: var(--text); }

    header .settings-btn { color: rgba(255, 255, 255, 0.5); }
    header .settings-btn:hover,
    header .settings-btn[aria-expanded="true"] {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.15);
      color: rgba(255, 255, 255, 0.9);
    }
    html[data-theme="dark"] header .settings-btn { color: var(--text-muted); }
    html[data-theme="dark"] header .settings-btn:hover,
    html[data-theme="dark"] header .settings-btn[aria-expanded="true"] {
      background: var(--surface-alt);
      border-color: var(--border);
      color: var(--text);
    }

    /* Tools panel */
    .tools-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-slow) var(--ease), border-color var(--duration-slow) var(--ease);
      border-bottom: 1px solid transparent;
    }

    .tools-panel[data-collapsed="false"] {
      max-height: 600px;
      border-bottom-color: var(--border);
    }

    .tools-panel-inner {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      padding: var(--space-md) var(--space-lg);
    }

    .tools-toggle {
      min-height: 44px;
      padding: 0 12px;
      font-size: var(--text-sm);
      font-family: var(--font);
      color: rgba(255, 255, 255, 0.5);
      background: none;
      border: none;
      cursor: pointer;
      transition: color var(--duration) var(--ease);
    }

    .tools-toggle:hover { color: rgba(255, 255, 255, 0.9); }
    html[data-theme="dark"] .tools-toggle { color: var(--text-muted); }
    html[data-theme="dark"] .tools-toggle:hover { color: var(--text); }

    .tool-item {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 12px var(--space-md);
      flex: 1 1 280px;
      max-width: 400px;
      box-shadow: var(--shadow-sm);
    }

    .tool-item-name {
      font-family: var(--mono);
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--accent);
      margin-bottom: var(--space-xs);
    }

    .tool-item-badges {
      display: flex;
      gap: 6px;
      margin-bottom: 6px;
    }

    .annotation-badge {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      padding: 2px var(--space-sm);
      border-radius: 100px;
    }

    .annotation-badge.read-only { background: var(--badge-green-bg); color: var(--size-small); }
    .annotation-badge.idempotent { background: var(--badge-cyan-bg); color: var(--accent); }
    .annotation-badge.destructive { background: var(--badge-red-bg); color: var(--size-large); }
    .annotation-badge.closed-world { background: var(--badge-amber-bg); color: var(--size-med); }

    .tool-item-desc {
      font-size: var(--text-xs);
      color: var(--text-muted);
      line-height: 1.5;
    }

    .tool-item.new {
      border: 1px solid var(--accent);
    }

    .tool-item-params {
      font-size: var(--text-xs);
      color: var(--accent);
      margin-top: var(--space-xs);
      font-family: var(--mono);
    }

    @media (max-width: 900px) {
      body { flex-direction: column; }
      .chat-panel { border-left: none; border-top: 1px solid var(--border); max-height: 50dvh; width: 100%; }
    }

    main { padding: var(--space-lg); overflow-y: auto; flex: 1; min-height: 0; }

    .controls {
      display: flex;
      gap: var(--space-sm);
      margin-bottom: var(--space-lg);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      mask-image: linear-gradient(to right, black calc(100% - 32px), transparent);
      -webkit-mask-image: linear-gradient(to right, black calc(100% - 32px), transparent);
      padding-right: var(--space-xl);
    }

    .controls::-webkit-scrollbar { display: none; }

    .controls.at-end {
      mask-image: none;
      -webkit-mask-image: none;
      padding-right: 0;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      min-height: 44px;
      padding: 0 var(--space-md);
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--text-muted);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 100px;
      cursor: pointer;
      text-decoration: none;
      white-space: nowrap;
      flex-shrink: 0;
      transition: background var(--duration) var(--ease), color var(--duration) var(--ease), border-color var(--duration) var(--ease);
    }

    .chip:hover { background: var(--surface-alt); color: var(--text); }
    .chip.active { background: var(--accent-dim); color: var(--accent); border-color: var(--accent); }

    .chip-separator {
      width: 1px;
      height: 28px;
      background: var(--border);
      align-self: center;
      flex-shrink: 0;
    }

    #display { min-height: 200px; }

    .empty-state {
      padding: var(--space-2xl) var(--space-lg);
      text-align: center;
      color: var(--text-muted);
      font-size: var(--text-sm);
    }

    /* Loading skeleton */
    @keyframes shimmer {
      0% { background-position: -400px 0; }
      100% { background-position: 400px 0; }
    }

    .loading-skeleton {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .skeleton-row {
      height: 44px;
      border-radius: var(--radius);
      background: linear-gradient(90deg, var(--surface) 25%, var(--surface-alt) 50%, var(--surface) 75%);
      background-size: 800px 44px;
      animation: shimmer 1.5s infinite linear;
    }

    /* Table view */
    .table-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .country-table {
      width: 100%;
      border-collapse: collapse;
      font-size: var(--text-sm);
      min-width: 640px;
    }

    .country-table th,
    .compare-table th {
      text-align: left;
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
    }

    .country-table th {
      padding: 10px 12px;
      white-space: nowrap;
    }

    .country-table td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--surface-alt);
      white-space: nowrap;
    }

    .country-table tbody tr {
      cursor: pointer;
      transition: background var(--duration) var(--ease);
    }

    .country-table tbody tr:hover { background: var(--surface); }
    .country-table tbody tr:focus-visible { outline: 2px solid var(--accent); outline-offset: -2px; }

    .country-name-cell {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .size-badge {
      display: inline-block;
      padding: 2px 10px;
      font-size: var(--text-xs);
      font-weight: 600;
      border-radius: 100px;
      letter-spacing: 0.04em;
    }

    .size-badge.small { background: var(--badge-green-bg); color: var(--size-small); }
    .size-badge.medium { background: var(--badge-amber-bg); color: var(--size-med); }
    .size-badge.large { background: var(--badge-red-bg); color: var(--size-large); }

    /* Flag dot */
    .flag-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--flag);
      flex-shrink: 0;
    }

    .flag-note {
      padding: var(--space-sm) var(--space-lg) 0;
      font-size: var(--text-sm);
      color: var(--flag);
      font-style: italic;
    }

    /* Comparison view */
    .compare-table {
      width: 100%;
      max-width: 640px;
      border-collapse: collapse;
      font-size: var(--text-sm);
    }

    .compare-table th {
      padding: 10px var(--space-md);
    }

    .compare-table td {
      padding: 12px var(--space-md);
      border-bottom: 1px solid var(--surface-alt);
    }

    .compare-metric {
      color: var(--text-muted);
      font-size: var(--text-sm);
    }

    .compare-value {
      font-variant-numeric: tabular-nums;
      font-weight: 500;
    }

    /* Detail view */
    .detail-card {
      max-width: 640px;
      background: var(--surface);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow);
    }

    .detail-header {
      padding: 20px var(--space-lg);
      border-bottom: 1px solid var(--surface-alt);
    }

    .detail-header h2 {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: var(--text-xl);
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: var(--space-xs);
    }

    .detail-meta {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }

    .detail-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1px;
      background: var(--surface-alt);
    }

    .detail-cell {
      padding: var(--space-md) var(--space-lg);
      background: var(--surface);
    }

    .detail-cell-label {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: var(--space-xs);
    }

    .detail-cell-value {
      font-size: var(--text-lg);
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
    }

    .detail-cell-value-text {
      font-size: var(--text-sm);
      font-weight: 500;
      line-height: 1.4;
      word-break: break-word;
      white-space: normal;
    }

    .detail-suffix {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }

    .view-label {
      font-size: var(--text-sm);
      color: var(--text-muted);
      margin-bottom: var(--space-md);
    }

    .chart-container {
      width: 100%;
      min-height: 400px;
    }

    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      min-height: 44px;
      padding: 0 var(--space-md);
      font-size: var(--text-sm);
      font-family: var(--font);
      color: var(--accent);
      background: none;
      border: 1px solid var(--accent-dim);
      border-radius: var(--radius);
      cursor: pointer;
      margin-bottom: var(--space-md);
      transition: background var(--duration) var(--ease);
    }

    .back-btn:hover { background: var(--accent-dim); }

    /* Summary grid */
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-md);
    }

    .summary-card {
      background: var(--surface);
      border-radius: var(--radius-lg);
      padding: 20px var(--space-lg);
      box-shadow: var(--shadow-sm);
      transition: box-shadow var(--duration) var(--ease), transform var(--duration) var(--ease);
    }

    .summary-card:hover {
      box-shadow: var(--shadow);
      transform: translateY(-1px);
    }

    .summary-card-value {
      font-size: var(--text-2xl);
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
      margin-bottom: var(--space-xs);
    }

    .summary-card-label {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: var(--space-xs);
    }

    .summary-card-meta {
      font-size: var(--text-sm);
      color: var(--text-muted);
    }
  </style>
  <link rel="stylesheet" href="../chat.css">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/marked@15/marked.min.js" as="script">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js" as="script">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js" as="script">
  <script src="https://cdn.jsdelivr.net/npm/marked@15/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
  <div class="main-column">
    <header>
      <div class="header-left">
        <h1>WebMCP PoC</h1>
        <button class="tools-toggle" id="tools-toggle" aria-expanded="false" aria-controls="tools-panel">&#9660; 7 tools</button>
      </div>
      <div class="settings-wrap">
        <button class="settings-btn" id="settings-btn" aria-label="Settings" aria-expanded="false" aria-controls="settings-popover" title="Settings">
          <svg width="15" height="15" viewBox="0 0 15 15" fill="none" aria-hidden="true">
            <path d="M6.08 1.5a.5.5 0 0 0-.495.43l-.198 1.382a4.5 4.5 0 0 0-.968.565L3.1 3.29a.5.5 0 0 0-.617.172L1.5 4.9a.5.5 0 0 0 .1.657l1.1.9A4.5 4.5 0 0 0 2.6 7.5c0 .328.034.648.1.943l-1.1.9a.5.5 0 0 0-.1.657l.984 1.438a.5.5 0 0 0 .617.172l1.319-.588c.298.213.617.398.968.565l.198 1.383a.5.5 0 0 0 .495.43h1.84a.5.5 0 0 0 .495-.43l.198-1.383a4.5 4.5 0 0 0 .968-.565l1.319.588a.5.5 0 0 0 .617-.172L13.4 10a.5.5 0 0 0-.1-.657l-1.1-.9c.066-.295.1-.615.1-.943s-.034-.648-.1-.943l1.1-.9A.5.5 0 0 0 13.5 4.9l-.984-1.438a.5.5 0 0 0-.617-.172l-1.319.588a4.5 4.5 0 0 0-.968-.565L9.415 1.93A.5.5 0 0 0 8.92 1.5H6.08ZM7.5 9.5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Z" fill="currentColor"/>
          </svg>
        </button>
        <div class="settings-popover" id="settings-popover" hidden role="dialog" aria-label="Settings">

          <div class="settings-section">
            <div class="settings-section-label">Appearance</div>
            <div class="theme-toggle" role="group" aria-label="Color theme">
              <button class="theme-opt" data-theme="system">System</button>
              <button class="theme-opt" data-theme="light">Light</button>
              <button class="theme-opt" data-theme="dark">Dark</button>
            </div>
          </div>

          <div class="settings-section">
            <div class="settings-section-label">AI Model</div>
            <select class="chat-model-select" id="model-select" aria-label="Model">
              <option value="anthropic:claude-haiku-4-5-20251001">Claude Haiku 4.5</option>
              <option value="anthropic:claude-sonnet-4-6">Claude Sonnet 4.6</option>
              <option value="local:claude" hidden>Claude &middot; Personal account</option>
              <option value="github:openai/gpt-4.1">GitHub &middot; GPT-4.1</option>
              <option value="github:openai/gpt-4.1-mini">GitHub &middot; GPT-4.1 mini</option>
              <option value="github:openai/gpt-5">GitHub &middot; GPT-5</option>
              <option value="github:openai/gpt-5-mini">GitHub &middot; GPT-5 mini</option>
            </select>
          </div>

          <form class="settings-section" id="chat-claude-bar" onsubmit="event.preventDefault()">
            <div class="settings-section-label">Anthropic API Key</div>
            <div class="settings-auth-row">
              <input type="password" class="chat-auth-input" id="api-key" placeholder="sk-ant-&#8230;" autocomplete="off" aria-label="Anthropic API key">
              <button type="submit" class="btn btn-sm" id="key-save">Save</button>
            </div>
          </form>

          <div class="settings-section" id="github-auth-bar">
            <!-- rendered by updateGitHubAuthBar() -->
          </div>

          <div class="github-notice settings-notice" id="github-notice" hidden>
            <span>&#9888; Tool calls may be less reliable with GitHub Models than with Claude.</span>
            <button class="github-notice-dismiss" id="github-notice-dismiss" aria-label="Dismiss">&#x2715;</button>
          </div>

        </div>
      </div>
    </header>

    <div class="tools-panel" id="tools-panel" data-collapsed="true">
      <div class="tools-panel-inner" id="tools-panel-inner"></div>
    </div>

    <main>
      <nav class="controls" aria-label="Filters">
        <button class="chip active" data-filter="all">All</button>
        <button class="chip" data-filter="Americas">Americas</button>
        <button class="chip" data-filter="Europe">Europe</button>
        <button class="chip" data-filter="Asia">Asia</button>
        <button class="chip" data-filter="Africa">Africa</button>
        <button class="chip" data-filter="Oceania">Oceania</button>
        <div class="chip-separator"></div>
        <button class="chip" data-view="chart">Population Chart</button>
        <button class="chip" data-filter="large">Large Countries Only</button>
      </nav>

      <div id="display"></div>
    </main>
  </div>

  <aside class="chat-panel">
    <div class="chat-header">
      <span class="chat-header-title">AI Chat</span>
      <span class="chat-model-label" id="chat-model-label">Claude</span>
      <button class="btn btn-sm" id="chat-reset" aria-label="Clear chat">Clear</button>
    </div>
    <div class="chat-messages" id="chat-messages" aria-live="polite" aria-label="Chat messages"></div>
    <div class="chat-input-area">
      <div class="chat-input-wrap">
        <textarea class="chat-input" id="chat-input" placeholder="Ask about countries&#8230;" rows="3" aria-label="Chat message"></textarea>
        <button class="chat-send-btn" id="chat-send" aria-label="Send message" title="Send">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true">
            <path d="M8 13V3M3.5 7.5L8 3l4.5 4.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <button class="chat-abort-btn" id="chat-abort" hidden aria-label="Stop generating" title="Stop">
          <svg width="11" height="11" viewBox="0 0 11 11" aria-hidden="true">
            <rect width="11" height="11" rx="2" fill="currentColor"/>
          </svg>
        </button>
      </div>
    </div>
  </aside>

  <div class="toast-container" id="toast-container" role="status" aria-live="polite"></div>

  <dialog id="confirm-dialog" aria-labelledby="confirm-title">
    <form method="dialog">
      <p class="dialog-title" id="confirm-title">Confirm action</p>
      <p class="dialog-tool" id="confirm-tool"></p>
      <p class="dialog-args" id="confirm-args"></p>
      <div class="dialog-actions">
        <button class="btn-cancel" value="cancel">Cancel</button>
        <button class="btn-confirm" value="confirm">Confirm</button>
      </div>
    </form>
  </dialog>

  <dialog id="prompt-dialog" aria-labelledby="prompt-title">
    <form method="dialog">
      <p class="dialog-title" id="prompt-title"></p>
      <input type="text" class="dialog-input" id="prompt-input" autocomplete="off">
      <div class="dialog-actions">
        <button class="btn-cancel" value="cancel">Skip</button>
        <button class="btn-confirm" value="confirm">Add</button>
      </div>
    </form>
  </dialog>

  <script>
    /* ── Theme ── */

    (function () {
      const stored = localStorage.getItem('webmcp-theme') || 'light';
      const resolved = stored === 'system'
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
        : stored;
      document.documentElement.dataset.theme = resolved;
    })();

    marked.use({ gfm: true, breaks: true });

    /* ── Dataset ── */

    let COUNTRIES = [];

    /* ── State ── */

    const flaggedCountries = new Map();
    let currentView = { type: 'table', data: null, label: null, filters: null };
    let currentToastTimeout = null;
    let previousToolNames = new Set();
    let toolsInitialized = false;

    /* ── Constants ── */

    const QUICK_ACTIONS = [
      'Show European countries',
      'Compare USA and China',
      'Population by region as a pie chart',
      'Top 10 countries by area as a bar chart',
      'Plot population vs area as scatter'
    ];

    /* ── Utilities ── */

    function sizeTier(population) {
      if (population >= 50000000) return 'large';
      if (population >= 10000000) return 'medium';
      return 'small';
    }

    function matchName(country, query) {
      return country.name.toLowerCase().includes(query.toLowerCase());
    }

    function filterData({ region, subregion, search, size } = {}) {
      return COUNTRIES.filter(c => {
        if (region && c.region !== region) return false;
        if (subregion && c.subregion !== subregion) return false;
        if (size && sizeTier(c.population) !== size) return false;
        if (search && !matchName(c, search)) return false;
        return true;
      });
    }

    function scrollDisplayIntoView() {
      if (window.matchMedia('(max-width: 900px)').matches) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      } else {
        display.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function refreshCurrentView() {
      if (currentView.type === 'table') {
        renderTable(currentView.data || COUNTRIES, currentView.label, currentView.filters);
      } else if (currentView.type === 'chart' && currentView.data) {
        renderEChart(currentView.data, currentView.label);
      } else if (currentView.type === 'detail' && currentView.data) {
        renderDetail(currentView.data);
      } else if (currentView.type === 'comparison' && currentView.data) {
        renderComparison(currentView.data[0], currentView.data[1]);
      }
    }

    /* ── URL State ── */

    function encodeViewToHash() {
      const params = new URLSearchParams();
      params.set('view', currentView.type);
      const f = currentView.filters || {};

      if (currentView.type === 'table') {
        if (f.region) params.set('region', f.region);
        if (f.size) params.set('size', f.size);
      } else if (currentView.type === 'detail' && currentView.data) {
        params.set('name', currentView.data.name);
      } else if (currentView.type === 'comparison' && currentView.data) {
        params.set('c1', currentView.data[0].name);
        params.set('c2', currentView.data[1].name);
      }

      history.replaceState(null, '', '#' + params.toString());
    }

    function decodeHashToView() {
      const hash = location.hash.slice(1);
      if (!hash) return false;

      const params = new URLSearchParams(hash);
      const view = params.get('view');

      if (view === 'table') {
        const region = params.get('region');
        const size = params.get('size');
        if (region) {
          renderTable(filterData({ region }), `countries in ${region}`, { region });
        } else if (size) {
          renderTable(filterData({ size }), `${size} countries`, { size });
        } else {
          renderTable(COUNTRIES);
        }
        return true;
      }

      if (view === 'chart') {
        renderTable(COUNTRIES);
        return true;
      }

      if (view === 'detail') {
        const name = params.get('name');
        const c = COUNTRIES.find(c => c.name === name);
        if (c) { renderDetail(c); return true; }
      }

      if (view === 'comparison') {
        const c1 = COUNTRIES.find(c => c.name === params.get('c1'));
        const c2 = COUNTRIES.find(c => c.name === params.get('c2'));
        if (c1 && c2) { renderComparison(c1, c2); return true; }
      }

      return false;
    }

    window.addEventListener('hashchange', () => {
      if (COUNTRIES.length) decodeHashToView();
    });

    /* ── Rendering ── */

    const display = document.getElementById('display');

    echarts.registerTheme('webmcp', {
      backgroundColor: 'transparent',
      textStyle: { fontFamily: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif" },
      title: { textStyle: { color: '#f1f5f9' } },
      legend: { textStyle: { color: '#94a3b8' } },
      categoryAxis: {
        axisLine: { lineStyle: { color: '#475569' } },
        axisLabel: { color: '#94a3b8' },
        splitLine: { lineStyle: { color: '#1e293b' } }
      },
      valueAxis: {
        axisLine: { lineStyle: { color: '#475569' } },
        axisLabel: { color: '#94a3b8' },
        splitLine: { lineStyle: { color: '#1e293b' } }
      },
      tooltip: {
        backgroundColor: '#1e293b',
        borderColor: '#475569',
        textStyle: { color: '#f1f5f9' }
      }
    });

    let chartInstance = null;

    function renderEChart(option, label) {
      currentView = { type: 'chart', data: option, label, filters: {} };
      if (chartInstance) { chartInstance.dispose(); chartInstance = null; }
      display.innerHTML = `
        <p class="view-label">${label}</p>
        <div id="chart-container" class="chart-container"></div>
      `;
      const container = document.getElementById('chart-container');
      chartInstance = echarts.init(container, 'webmcp');
      chartInstance.setOption(option);
      encodeViewToHash();
      syncTools();
    }

    window.addEventListener('resize', () => {
      if (chartInstance) chartInstance.resize();
    });

    function renderSkeleton() {
      display.innerHTML = `
        <div class="loading-skeleton">
          ${Array.from({ length: 8 }, (_, i) =>
            `<div class="skeleton-row" style="animation-delay: ${i * 80}ms"></div>`
          ).join('')}
        </div>
      `;
    }

    function renderTable(countries, label, filters) {
      currentView = { type: 'table', data: countries, label, filters };
      const summary = label || `${countries.length} countries`;

      if (countries.length === 0) {
        display.innerHTML = `<p class="empty-state">No countries match the current filters.</p>`;
        encodeViewToHash();
        syncTools();
        return;
      }

      display.innerHTML = `
        <div class="summary-row">
          <p class="view-label">Showing ${summary}</p>
          <span class="summary-count">${countries.length} result${countries.length !== 1 ? 's' : ''}</span>
        </div>
        <div class="table-scroll">
        <table class="country-table">
          <thead>
            <tr>
              <th>Country</th>
              <th>Region</th>
              <th>Population</th>
              <th>Area (km&sup2;)</th>
              <th>Capital</th>
            </tr>
          </thead>
          <tbody>
            ${countries.map(c => {
              const isFlagged = flaggedCountries.has(c.name);
              return `
              <tr tabindex="0" data-name="${c.name}">
                <td><span class="country-name-cell">${isFlagged ? '<span class="flag-dot" title="Flagged"></span>' : ''}${c.flag} ${c.name}</span></td>
                <td>${c.region}</td>
                <td>${c.population.toLocaleString()}</td>
                <td>${c.area.toLocaleString()}</td>
                <td>${c.capital}</td>
              </tr>`;
            }).join('')}
          </tbody>
        </table>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderDetail(country) {
      const c = country;
      const tier = sizeTier(c.population);
      const flag = flaggedCountries.get(c.name);
      currentView = { type: 'detail', data: c, label: null, filters: null };

      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <div class="detail-card">
          <div class="detail-header">
            <h2>${flag ? '<span class="flag-dot"></span>' : ''}${c.flag} ${c.name}</h2>
            <p class="detail-meta">${c.region} &middot; ${c.subregion} &middot; ${c.capital}</p>
          </div>
          ${flag ? `<p class="flag-note">${flag.note.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</p>` : ''}
          <div class="detail-grid">
            <div class="detail-cell">
              <div class="detail-cell-label">Population</div>
              <div class="detail-cell-value">${c.population.toLocaleString()}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Area</div>
              <div class="detail-cell-value">${c.area.toLocaleString()}<span class="detail-suffix"> km&sup2;</span></div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Population Density</div>
              <div class="detail-cell-value">${c.populationDensity.toLocaleString()}<span class="detail-suffix"> /km&sup2;</span></div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Languages</div>
              <div class="detail-cell-value detail-cell-value-text">${c.languages}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Currencies</div>
              <div class="detail-cell-value detail-cell-value-text">${c.currencies}</div>
            </div>
            <div class="detail-cell">
              <div class="detail-cell-label">Independent</div>
              <div class="detail-cell-value">${c.independent ? 'Yes' : 'No'}</div>
            </div>
          </div>
        </div>
      `;
      encodeViewToHash();
      syncTools();
    }

    function renderComparison(c1, c2) {
      currentView = { type: 'comparison', data: [c1, c2], label: null, filters: null };

      const metrics = [
        { label: 'Population', key: 'population', format: v => v.toLocaleString() },
        { label: 'Area (km\u00B2)', key: 'area', format: v => v.toLocaleString() },
        { label: 'Population Density', key: 'populationDensity', format: v => v.toLocaleString() + ' /km\u00B2' },
        { label: 'Languages', key: 'languages', format: v => v },
        { label: 'Currencies', key: 'currencies', format: v => v },
        { label: 'Independent', key: 'independent', format: v => v ? 'Yes' : 'No' },
      ];

      display.innerHTML = `
        <button class="back-btn">&#8592; Back to list</button>
        <p class="view-label">Comparing two countries</p>
        <table class="compare-table">
          <thead>
            <tr>
              <th>Metric</th>
              <th>${c1.flag} ${c1.name}</th>
              <th>${c2.flag} ${c2.name}</th>
            </tr>
          </thead>
          <tbody>
            ${metrics.map(m => `
              <tr>
                <td class="compare-metric">${m.label}</td>
                <td class="compare-value">${m.format(c1[m.key])}</td>
                <td class="compare-value">${m.format(c2[m.key])}</td>
              </tr>`).join('')}
          </tbody>
        </table>
      `;
      encodeViewToHash();
      syncTools();
    }

    /* ── Display event delegation ── */

    display.addEventListener('click', (e) => {
      const row = e.target.closest('tr[data-name]');
      if (row) { showDetail(row.dataset.name); return; }
      const backBtn = e.target.closest('.back-btn');
      if (backBtn) renderTable(COUNTRIES);
    });

    display.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      const row = e.target.closest('tr[data-name]');
      if (row) showDetail(row.dataset.name);
    });

    function showDetail(name) {
      const c = COUNTRIES.find(c => c.name === name);
      if (!c) return;
      renderDetail(c);
    }

    /* ── Toast ── */

    function showToast(message, onUndo) {
      dismissToast();

      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'toast';

      const msgSpan = document.createElement('span');
      msgSpan.className = 'toast-message';
      msgSpan.textContent = message;
      toast.appendChild(msgSpan);

      const undoBtn = document.createElement('button');
      undoBtn.className = 'toast-undo';
      undoBtn.textContent = 'Undo';
      undoBtn.addEventListener('click', () => {
        dismissToast();
        onUndo();
      });
      toast.appendChild(undoBtn);

      container.appendChild(toast);
      currentToastTimeout = setTimeout(dismissToast, 5000);
    }

    function dismissToast() {
      if (currentToastTimeout) {
        clearTimeout(currentToastTimeout);
        currentToastTimeout = null;
      }
      document.getElementById('toast-container').innerHTML = '';
    }

    /* ── Persistence ── */

    function persistFlags() {
      const data = [...flaggedCountries.entries()].map(([name, flag]) => ({ name, ...flag }));
      localStorage.setItem('webmcp-country-flags', JSON.stringify(data));
    }

    function loadFlags() {
      try {
        const data = JSON.parse(localStorage.getItem('webmcp-country-flags') || '[]');
        data.forEach(({ name, ...flag }) => flaggedCountries.set(name, flag));
      } catch {}
    }

    /* ── Confirmation dialog ── */

    function showConfirmDialog(toolName, args) {
      const dialog = document.getElementById('confirm-dialog');
      document.getElementById('confirm-tool').textContent = toolName;
      document.getElementById('confirm-args').textContent = JSON.stringify(args, null, 2);
      dialog.returnValue = '';
      dialog.showModal();
      return new Promise(resolve => {
        dialog.addEventListener('close', () => {
          resolve(dialog.returnValue === 'confirm');
        }, { once: true });
      });
    }

    function showPromptDialog(message) {
      const dialog = document.getElementById('prompt-dialog');
      const input = document.getElementById('prompt-input');
      document.getElementById('prompt-title').textContent = message;
      input.value = '';
      dialog.returnValue = '';
      dialog.showModal();
      input.focus();
      function onEnter(e) {
        if (e.key === 'Enter') { e.preventDefault(); dialog.close('confirm'); }
      }
      input.addEventListener('keydown', onEnter);
      return new Promise(resolve => {
        dialog.addEventListener('close', () => {
          input.removeEventListener('keydown', onEnter);
          resolve(dialog.returnValue === 'confirm' ? (input.value || null) : null);
        }, { once: true });
      });
    }

    /* ── Keyboard shortcuts ── */

    document.addEventListener('keydown', (e) => {
      if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey && !e.target.matches('input, textarea')) {
        chatInput.focus();
      }
      if (e.key === 'Escape') {
        const sp = document.getElementById('settings-popover');
        const sb = document.getElementById('settings-btn');
        if (sp && !sp.hidden) {
          sp.hidden = true;
          sb?.setAttribute('aria-expanded', 'false');
          sb?.focus();
          return;
        }
        const panel = document.getElementById('tools-panel');
        if (panel.dataset.collapsed === 'false') { toggleToolsPanel(); return; }
        dismissToast();
      }
    });

    /* ── Controls scroll fade ── */

    const controlsNav = document.querySelector('.controls');
    function updateScrollFade() {
      const atEnd = controlsNav.scrollLeft + controlsNav.clientWidth >= controlsNav.scrollWidth - 4;
      controlsNav.classList.toggle('at-end', atEnd);
    }
    controlsNav.addEventListener('scroll', updateScrollFade, { passive: true });
    updateScrollFade();

    /* ── Quick actions ── */

    function renderQuickActions() {
      const container = document.createElement('div');
      container.className = 'chat-quick-actions';
      container.id = 'quick-actions';

      QUICK_ACTIONS.forEach(prompt => {
        const btn = document.createElement('button');
        btn.className = 'suggestion-chip quick-action-chip';
        btn.textContent = prompt;
        btn.addEventListener('click', () => {
          sendMessage({ prompt });
        });
        container.appendChild(btn);
      });

      chatMessages.appendChild(container);
    }

    /* ── Follow-up suggestions ── */

    function getFollowupSuggestions() {
      const suggestions = [];

      switch (currentView.type) {
        case 'table': {
          suggestions.push('Show population chart');
          const large = (currentView.data || COUNTRIES)
            .filter(c => sizeTier(c.population) === 'large')
            .sort((a, b) => b.population - a.population);
          if (large.length >= 2) {
            suggestions.push(`Compare ${large[0].name} and ${large[1].name}`);
          }
          break;
        }
        case 'chart':
          suggestions.push('Show table view');
          suggestions.push('Filter to large countries only');
          break;
        case 'detail': {
          const c = currentView.data;
          suggestions.push(`Flag ${c.name}`);
          const sameRegion = COUNTRIES
            .filter(other => other.name !== c.name && other.region === c.region)
            .sort((a, b) =>
              Math.abs(a.population - c.population) - Math.abs(b.population - c.population)
            );
          if (sameRegion.length) {
            suggestions.push(`Compare with ${sameRegion[0].name}`);
          }
          break;
        }
        case 'comparison': {
          const [c1, c2] = currentView.data;
          const larger = c1.population > c2.population ? c1 : c2;
          suggestions.push(`Show detail for ${larger.name}`);
          suggestions.push(`Flag ${larger.name}`);
          break;
        }
      }

      return suggestions.slice(0, 2);
    }

    function renderFollowupSuggestions() {
      clearFollowupSuggestions();
      const suggestions = getFollowupSuggestions();
      if (!suggestions.length) return;

      const container = document.createElement('div');
      container.className = 'followup-suggestions';
      container.id = 'followup-suggestions';

      suggestions.forEach(text => {
        const btn = document.createElement('button');
        btn.className = 'suggestion-chip followup-chip';
        btn.textContent = text;
        btn.addEventListener('click', () => {
          sendMessage({ prompt: text });
        });
        container.appendChild(btn);
      });

      chatMessages.appendChild(container);
    }

    function clearFollowupSuggestions() {
      const existing = document.getElementById('followup-suggestions');
      if (existing) existing.remove();
    }

    /* ── Dynamic tools ── */

    function getContextualTools() {
      const tools = [];
      if (flaggedCountries.size > 0) {
        tools.push({
          name: 'review_flags',
          title: 'Review Flags',
          description: `Show all ${flaggedCountries.size} currently flagged countries with their notes and region.`,
          readOnlyHint: true,
          idempotentHint: true,
          destructiveHint: false,
          openWorldHint: false,
          schema: { type: 'object', properties: {} },
          exec: async () => {
            const flagged = [...flaggedCountries.keys()]
              .map(name => COUNTRIES.find(c => c.name === name))
              .filter(Boolean);
            renderTable(flagged, 'flagged countries');
            return {
              displayed: true,
              count: flagged.length,
              summary: `Showing ${flagged.length} flagged country(ies).`,
              countries: flagged.map(c => ({
                name: c.name,
                note: flaggedCountries.get(c.name).note,
                region: c.region
              }))
            };
          }
        });
        tools.push({
          name: 'clear_all_flags',
          title: 'Clear All Flags',
          description: `Remove all ${flaggedCountries.size} country flags. This action cannot be undone.`,
          readOnlyHint: false,
          idempotentHint: true,
          destructiveHint: true,
          openWorldHint: false,
          schema: { type: 'object', properties: {} },
          exec: async (input, client) => {
            const count = flaggedCountries.size;
            const confirmed = await client.requestUserInteraction(() =>
              showConfirmDialog(`Clear all ${count} flags`, { flags: [...flaggedCountries.keys()] })
            );
            if (!confirmed) return { summary: 'User cancelled.' };
            flaggedCountries.clear();
            persistFlags();
            refreshCurrentView();
            syncTools();
            return { summary: `Cleared ${count} flag(s).` };
          }
        });
      }
      return tools;
    }

    function getActiveTools() {
      const tools = TOOL_DEFS.map(t => {
        if (t.name === 'compare_countries') {
          const visible = (currentView.type === 'table' && currentView.data) ? currentView.data : COUNTRIES;
          const names = visible.map(c => c.name);
          return {
            ...t,
            schema: {
              ...t.schema,
              properties: {
                country1: { ...t.schema.properties.country1, enum: names },
                country2: { ...t.schema.properties.country2, enum: names }
              }
            }
          };
        }
        return t;
      });
      return [...tools, ...getContextualTools()];
    }

    function getPageContext() {
      const parts = [];
      switch (currentView.type) {
        case 'table':
          parts.push('Table');
          if (currentView.data) parts.push(`${currentView.data.length} countries`);
          break;
        case 'chart': parts.push('Chart'); break;
        case 'detail':
          if (currentView.data) parts.push(`Detail: ${currentView.data.name}`);
          break;
        case 'comparison':
          if (currentView.data) parts.push(`${currentView.data[0].name} vs ${currentView.data[1].name}`);
          break;
      }
      if (currentView.filters?.region) parts.push(currentView.filters.region);
      if (currentView.filters?.size) parts.push(`${currentView.filters.size} countries`);
      if (flaggedCountries.size > 0) parts.push(`${flaggedCountries.size} flagged`);
      return parts;
    }

    function syncTools() {
      const tools = getActiveTools();
      const currentNames = new Set(tools.map(t => t.name));
      const newNames = toolsInitialized
        ? new Set([...currentNames].filter(n => !previousToolNames.has(n)))
        : new Set();

      previousToolNames = currentNames;
      renderToolsPanel(tools, newNames);
      toolsInitialized = true;
    }

    /* ── Tools panel ── */

    function renderToolsPanel(tools, newNames = new Set()) {
      const inner = document.getElementById('tools-panel-inner');
      const toggle = document.getElementById('tools-toggle');
      const panel = document.getElementById('tools-panel');
      const collapsed = panel.dataset.collapsed === 'true';
      toggle.innerHTML = `${collapsed ? '&#9660;' : '&#9650;'} ${tools.length} tools`;

      inner.innerHTML = tools.map(t => {
        const badges = [];
        if (t.readOnlyHint) badges.push('<span class="annotation-badge read-only">read-only</span>');
        if (t.idempotentHint) badges.push('<span class="annotation-badge idempotent">idempotent</span>');
        if (t.destructiveHint) badges.push('<span class="annotation-badge destructive">destructive</span>');
        if (!t.openWorldHint) badges.push('<span class="annotation-badge closed-world">closed-world</span>');

        const isNew = newNames.has(t.name);
        const countryEnum = Object.entries(t.schema.properties || {})
          .find(([k, v]) => v.enum && (k === 'country1' || k === 'country2'));
        const paramsHtml = countryEnum
          ? `<div class="tool-item-params">${countryEnum[1].enum.length} countries available</div>`
          : '';
        const desc = t.description.split('.')[0] + '.';

        return `
          <div class="tool-item${isNew ? ' new' : ''}">
            <div class="tool-item-name">${t.name}</div>
            <div class="tool-item-badges">${badges.join('')}</div>
            <div class="tool-item-desc">${desc}</div>
            ${paramsHtml}
          </div>
        `;
      }).join('');
    }

    function toggleToolsPanel() {
      const panel = document.getElementById('tools-panel');
      const toggle = document.getElementById('tools-toggle');
      const collapsed = panel.dataset.collapsed === 'true';
      panel.dataset.collapsed = collapsed ? 'false' : 'true';
      toggle.setAttribute('aria-expanded', collapsed ? 'true' : 'false');
      const tools = getActiveTools();
      toggle.innerHTML = `${collapsed ? '&#9650;' : '&#9660;'} ${tools.length} tools`;
    }

    document.getElementById('tools-toggle').addEventListener('click', toggleToolsPanel);

    /* ── Shared tool definitions ── */

    const TOOL_DEFS = [
      {
        name: 'filter_countries',
        title: 'Filter Countries',
        description: 'Filter and display world countries on the page. Renders a table showing matching countries with region, population, area, and capital. The user can then click any row to see full details.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            region: { type: 'string', enum: ['Americas', 'Europe', 'Asia', 'Africa', 'Oceania', 'Antarctic'], description: 'Filter by region' },
            subregion: { type: 'string', description: 'Filter by subregion (e.g. "Western Europe", "South America")' },
            search: { type: 'string', description: 'Search country name (partial match)' }
          }
        },
        exec: async (input) => {
          const filtered = filterData(input);
          const parts = [];
          if (input.region) parts.push(`in ${input.region}`);
          if (input.subregion) parts.push(`in ${input.subregion}`);
          if (input.search) parts.push(`matching "${input.search}"`);
          const label = parts.length ? parts.join(', ') : 'all countries';
          renderTable(filtered, label, { region: input.region });
          return { displayed: true, count: filtered.length, summary: `Rendered ${filtered.length} countries (${label}). User can now see the table and click any row for details.` };
        }
      },
      {
        name: 'show_country_detail',
        title: 'Country Detail',
        description: 'Display a detailed profile card for a specific country, showing population, area, density, languages, currencies, and independence status. Renders visually on the page.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'Country name (partial match supported)' }
          },
          required: ['name']
        },
        exec: async (input) => {
          const country = COUNTRIES.find(c => matchName(c, input.name));
          if (!country) return { displayed: false, summary: `No country found matching "${input.name}".` };
          renderDetail(country);
          return { displayed: true, summary: `Showing ${country.name} (${country.region}) -- population ${country.population.toLocaleString()}, area ${country.area.toLocaleString()} km\u00B2.` };
        }
      },
      {
        name: 'compare_countries',
        title: 'Compare Countries',
        description: 'Display a side-by-side comparison table of two countries across key metrics: population, area, population density, languages, currencies, and independence status.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            country1: { type: 'string', description: 'First country name (partial match)' },
            country2: { type: 'string', description: 'Second country name (partial match)' }
          },
          required: ['country1', 'country2']
        },
        exec: async (input) => {
          const c1 = COUNTRIES.find(c => matchName(c, input.country1));
          const c2 = COUNTRIES.find(c => matchName(c, input.country2));
          if (!c1) return { displayed: false, summary: `No country found matching "${input.country1}".` };
          if (!c2) return { displayed: false, summary: `No country found matching "${input.country2}".` };
          renderComparison(c1, c2);
          return { displayed: true, summary: `Comparing ${c1.name} vs ${c2.name}. Population ${c1.population.toLocaleString()} vs ${c2.population.toLocaleString()}, area ${c1.area.toLocaleString()} vs ${c2.area.toLocaleString()} km\u00B2.` };
        }
      },
      {
        name: 'render_chart',
        title: 'Render Chart',
        description: 'Render an Apache ECharts visualization. Generate a full ECharts option object with the appropriate chart type (bar, line, pie, scatter, radar, etc.) based on the data. Use the data available from previous tool calls. Colors should use the palette: ["#38bdf8", "#22c55e", "#f59e0b", "#ef4444", "#a78bfa", "#ec4899"].',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            option: {
              type: 'object',
              description: 'Full ECharts option object (series, xAxis, yAxis, tooltip, legend, etc.)'
            },
            label: {
              type: 'string',
              description: 'Short description shown above the chart'
            }
          },
          required: ['option', 'label']
        },
        exec: async (input) => {
          renderEChart(input.option, input.label);
          return { displayed: true, summary: `Chart rendered: ${input.label}` };
        }
      },
      {
        name: 'summarize_data',
        title: 'Summarize Data',
        description: 'Compute aggregate statistics for the country dataset. Returns numerical summaries (count, total population, average density, largest, smallest) without rendering any visualization.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            region: { type: 'string', enum: ['Americas', 'Europe', 'Asia', 'Africa', 'Oceania', 'Antarctic'], description: 'Limit summary to a specific region' }
          }
        },
        exec: async (input) => {
          const data = input.region ? filterData({ region: input.region }) : COUNTRIES;
          if (data.length === 0) return { summary: `No countries found for region "${input.region}".` };

          const totalPop = data.reduce((s, c) => s + c.population, 0);
          const totalArea = data.reduce((s, c) => s + c.area, 0);
          const avgDensity = Math.round(data.reduce((s, c) => s + c.populationDensity, 0) / data.length);

          const byPop = [...data].sort((a, b) => b.population - a.population);
          const largest = byPop[0];
          const smallest = byPop[byPop.length - 1];

          const scope = input.region || 'all regions';
          return {
            scope,
            count: data.length,
            totalPopulation: totalPop,
            totalArea: totalArea,
            avgDensity,
            largest: { name: largest.name, population: largest.population },
            smallest: { name: smallest.name, population: smallest.population },
            summary: `${data.length} countries (${scope}): total population ${totalPop.toLocaleString()}, avg density ${avgDensity}/km². Largest: ${largest.name} (${largest.population.toLocaleString()}), smallest: ${smallest.name} (${smallest.population.toLocaleString()}).`
          };
        }
      },
      {
        name: 'flag_country',
        title: 'Flag Country',
        description: 'Flag or unflag a country with a note. Flagged countries display an amber indicator dot in tables and detail views. Use this to mark countries that warrant attention or follow-up.',
        readOnlyHint: true,
        idempotentHint: false,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'Country name (partial match supported)' },
            note: { type: 'string', description: 'Reason for flagging (displayed on detail card)' },
            unflag: { type: 'boolean', description: 'Set to true to remove the flag' }
          },
          required: ['name']
        },
        exec: async (input, client) => {
          const country = COUNTRIES.find(c => matchName(c, input.name));
          if (!country) return { summary: `No country found matching "${input.name}".` };

          if (input.unflag) {
            const previousFlag = flaggedCountries.get(country.name);
            flaggedCountries.delete(country.name);
            persistFlags();
            refreshCurrentView();
            showToast('Flag removed', () => {
              flaggedCountries.set(country.name, previousFlag || { note: 'Flagged for review', timestamp: Date.now() });
              persistFlags();
              refreshCurrentView();
            });
            return { summary: `Removed flag from ${country.name}.` };
          }

          let note = input.note;
          if (!note) {
            note = await client.requestUserInteraction(() =>
              showPromptDialog(`Add a note for flagging ${country.name} (optional)`)
            );
          }

          const flagData = { note: note || 'Flagged for review', timestamp: Date.now() };
          flaggedCountries.set(country.name, flagData);
          persistFlags();
          refreshCurrentView();
          showToast('Country flagged', () => {
            flaggedCountries.delete(country.name);
            persistFlags();
            refreshCurrentView();
          });
          return { summary: `Flagged ${country.name}: "${flagData.note}".` };
        }
      },
      {
        name: 'export_flagged',
        title: 'Export Flagged',
        description: 'Download a CSV file of all currently flagged countries with their flag notes and key metrics. Produces a file download, does not render a visualization.',
        readOnlyHint: true,
        idempotentHint: true,
        destructiveHint: false,
        openWorldHint: false,
        schema: {
          type: 'object',
          properties: {}
        },
        exec: async () => {
          if (flaggedCountries.size === 0) return { summary: 'No countries are currently flagged.' };

          const headers = ['Name', 'Region', 'Population', 'Area', 'Density', 'Flag Note', 'Flagged At'];
          const rows = [...flaggedCountries.entries()].map(([name, flag]) => {
            const c = COUNTRIES.find(c => c.name === name);
            return [name, c.region, c.population, c.area, c.populationDensity, flag.note, new Date(flag.timestamp).toISOString()];
          });

          const csv = [headers, ...rows].map(r => r.map(v => `"${v}"`).join(',')).join('\n');
          const blob = new Blob([csv], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'flagged-countries.csv';
          a.click();
          URL.revokeObjectURL(url);

          return { summary: `Exported ${flaggedCountries.size} flagged country(ies) as CSV.` };
        }
      }
    ];

    /* ── Button controls (mirror tool functionality) ── */

    document.querySelectorAll('.chip[data-filter]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');

        const filter = btn.dataset.filter;
        if (filter === 'all') {
          renderTable(COUNTRIES);
        } else if (filter === 'large') {
          const filtered = filterData({ size: 'large' });
          renderTable(filtered, 'large countries (50M+ population)', { size: 'large' });
        } else {
          const filtered = filterData({ region: filter });
          renderTable(filtered, `countries in ${filter}`, { region: filter });
        }
      });
    });

    document.querySelectorAll('.chip[data-view]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');

        const view = btn.dataset.view;
        if (view === 'chart') {
          const regions = {};
          COUNTRIES.forEach(c => { regions[c.region] = (regions[c.region] || 0) + 1; });
          const regionColors = { 'Asia': '#f59e0b', 'Africa': '#fb923c', 'Europe': '#a78bfa', 'Americas': '#38bdf8', 'Oceania': '#22c55e', 'Antarctic': '#94a3b8' };
          const sorted = ['Asia', 'Africa', 'Europe', 'Americas', 'Oceania', 'Antarctic'].filter(r => regions[r]);
          renderEChart({
            tooltip: { trigger: 'axis' },
            xAxis: { type: 'category', data: sorted },
            yAxis: { type: 'value' },
            series: [{ type: 'bar', data: sorted.map(r => ({ value: regions[r], itemStyle: { color: regionColors[r] } })) }]
          }, 'Countries by region');
        }
      });
    });

    /* ── Theme toggle ── */

    function applyTheme(pref) {
      localStorage.setItem('webmcp-theme', pref);
      const resolved = pref === 'system'
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
        : pref;
      document.documentElement.dataset.theme = resolved;
      const meta = document.querySelector('meta[name="theme-color"]');
      if (meta) meta.content = resolved === 'light' ? '#e8ebf2' : '#0f1117';
      document.querySelectorAll('.theme-opt').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.theme === pref);
      });
    }

    document.querySelectorAll('.theme-opt').forEach(btn => {
      btn.addEventListener('click', () => applyTheme(btn.dataset.theme));
    });

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      if (localStorage.getItem('webmcp-theme') === 'system') applyTheme('system');
    });

    applyTheme(localStorage.getItem('webmcp-theme') || 'light');

    /* ── Settings popover ── */

    const settingsBtn = document.getElementById('settings-btn');
    const settingsPopover = document.getElementById('settings-popover');

    settingsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const open = settingsPopover.hidden;
      settingsPopover.hidden = !open;
      settingsBtn.setAttribute('aria-expanded', String(open));
    });

    document.addEventListener('click', (e) => {
      if (settingsPopover && !settingsPopover.hidden &&
          !settingsPopover.contains(e.target) && e.target !== settingsBtn) {
        settingsPopover.hidden = true;
        settingsBtn.setAttribute('aria-expanded', 'false');
      }
    });

    /* ── Chat panel ── */

    const LOCAL_PROXY_URL = 'http://127.0.0.1:7337/claude';
    const GITHUB_CLIENT_ID = 'Ov23lioKDt8Os7hdiSEh';
    const CORS_PROXY_URL = 'https://cors-proxy.jonasneves.workers.dev';
    const OAUTH_CALLBACK_ORIGIN = 'https://neevs.io';
    const GITHUB_API_URL = 'https://models.github.ai/inference/chat/completions';

    let currentProvider = 'anthropic';
    let githubAuth = JSON.parse(localStorage.getItem('webmcp-gh-auth') || 'null');
    let ghMessages = [];

    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const chatAbort = document.getElementById('chat-abort');
    const chatReset = document.getElementById('chat-reset');
    const apiKeyInput = document.getElementById('api-key');
    const modelSelect = document.getElementById('model-select');
    const localOption = modelSelect.querySelector('option[value="local:claude"]');

    const SYSTEM_PROMPT_BASE = `You are embedded in a WebMCP proof-of-concept that explores world country data. Your tools render visuals (tables, charts, detail cards, comparisons) directly on the page \u2014 the user already sees the full result. You only receive a brief summary.

Rules:
- 1-2 sentences max after a tool call. Never redescribe what the visualization already shows.
- Call tools eagerly. If the user asks to see data, call the tool \u2014 don't narrate what you're about to do.
- End with a short follow-up suggestion (one line) so the user knows what else they can explore.
- No markdown formatting \u2014 this renders as plain text in a chat bubble.
- No greetings, filler, or preamble.
- You can flag countries to mark them for attention. Use flag_country when the user wants to mark, note, or bookmark a country.
- You can compare two countries side-by-side. Use compare_countries when the user wants to see differences.
- Use summarize_data to compute aggregate statistics before writing analysis. This tool returns numbers without rendering \u2014 use the data to write insights.
- Use export_flagged to download a CSV of all flagged countries when the user wants to export or save their flags.
- Use render_chart to display Apache ECharts visualizations. Generate a full ECharts option object choosing the best chart type (bar, line, pie, scatter, radar, etc.) for the data. Use the color palette: ["#38bdf8", "#22c55e", "#f59e0b", "#ef4444", "#a78bfa", "#ec4899"]. The theme already sets backgroundColor to transparent.
- Your available tools change dynamically based on page state. When countries are flagged, review_flags and clear_all_flags become available. Tool schemas also adapt \u2014 compare_countries only lists currently visible countries.
- When the user gives a short or ambiguous input (like "flag" or "compare"), infer the target from the current view context below. If viewing a detail card, act on that country. If viewing a filtered table, act on visible countries.`;

    function getSystemPrompt() {
      const lines = [SYSTEM_PROMPT_BASE, '', 'Current page state:'];
      switch (currentView.type) {
        case 'table': {
          const data = currentView.data || COUNTRIES;
          lines.push(`- Viewing: table of ${data.length} countries`);
          const names = data.slice(0, 8).map(c => c.name);
          lines.push(`- Visible: ${names.join(', ')}${data.length > 8 ? ` (+${data.length - 8} more)` : ''}`);
          break;
        }
        case 'detail':
          if (currentView.data) {
            const c = currentView.data;
            lines.push(`- Viewing: detail card for ${c.name} (${c.region}, population: ${c.population.toLocaleString()}, area: ${c.area.toLocaleString()} km\u00B2)`);
          }
          break;
        case 'chart':
          lines.push('- Viewing: region distribution chart');
          break;
        case 'comparison':
          if (currentView.data) {
            lines.push(`- Viewing: comparison of ${currentView.data[0].name} vs ${currentView.data[1].name}`);
          }
          break;
      }
      if (currentView.filters?.region) lines.push(`- Filtered by region: ${currentView.filters.region}`);
      if (currentView.filters?.size) lines.push(`- Filtered by size: ${currentView.filters.size}`);
      if (flaggedCountries.size > 0) {
        lines.push(`- Flagged countries (${flaggedCountries.size}): ${[...flaggedCountries.keys()].join(', ')}`);
      }
      return lines.join('\n');
    }

    function getClaudeTools() {
      return getActiveTools().map(t => ({ name: t.name, description: t.description, input_schema: t.schema }));
    }

    function getOpenAITools() {
      return getActiveTools().map(t => ({
        type: 'function',
        function: { name: t.name, description: t.description, parameters: t.schema || { type: 'object', properties: {} } }
      }));
    }

    let conversationMessages = [];
    let chatBusy = false;
    let abortController = null;

    // Restore API key: config.json > localStorage
    apiKeyInput.value = localStorage.getItem('webmcp-api-key') || '';

    fetch('config.json').then(r => r.ok ? r.json() : null).then(cfg => {
      if (cfg?.apiKey && !apiKeyInput.value) {
        apiKeyInput.value = cfg.apiKey;
        localStorage.setItem('webmcp-api-key', cfg.apiKey);
      }
    }).catch(() => {});

    async function checkLocalProxy() {
      try {
        const res = await fetch(LOCAL_PROXY_URL, { method: 'OPTIONS', signal: AbortSignal.timeout(800) });
        return res.status === 204;
      } catch {
        return false;
      }
    }

    function updateModelLabel() {
      const label = document.getElementById('chat-model-label');
      if (!label) return;
      const text = modelSelect.options[modelSelect.selectedIndex]?.text || '';
      label.textContent = text;
    }

    function applyProviderUI() {
      const isLocal = currentProvider === 'local';
      const isGitHub = currentProvider === 'github';

      const claudeBar = document.getElementById('chat-claude-bar');
      if (claudeBar) claudeBar.hidden = isLocal || isGitHub;

      updateGitHubAuthBar();
      const notice = document.getElementById('github-notice');
      notice.hidden = !isGitHub || !!localStorage.getItem('webmcp-github-notice-dismissed');

      updateModelLabel();
    }

    checkLocalProxy().then(running => {
      if (localOption) localOption.hidden = !running;
      const savedModel = localStorage.getItem('webmcp-model') || 'anthropic:claude-haiku-4-5-20251001';
      const fallback = (!running && savedModel === 'local:claude') ? 'anthropic:claude-haiku-4-5-20251001' : savedModel;
      modelSelect.value = fallback;
      currentProvider = fallback.split(':')[0];
      applyProviderUI();
    });

    modelSelect.addEventListener('change', () => {
      currentProvider = modelSelect.value.split(':')[0];
      localStorage.setItem('webmcp-model', modelSelect.value);
      applyProviderUI();
      conversationMessages = [];
      ghMessages = [];
      chatMessages.innerHTML = '';
      renderQuickActions();
    });

    apiKeyInput.addEventListener('input', () => localStorage.setItem('webmcp-api-key', apiKeyInput.value));

    document.getElementById('key-save')?.addEventListener('click', () => {
      localStorage.setItem('webmcp-api-key', apiKeyInput.value);
    });

    document.getElementById('github-notice-dismiss').addEventListener('click', () => {
      localStorage.setItem('webmcp-github-notice-dismissed', '1');
      document.getElementById('github-notice').hidden = true;
    });

    // Chat reset
    chatReset.addEventListener('click', () => {
      conversationMessages = [];
      ghMessages = [];
      chatMessages.innerHTML = '';
      renderQuickActions();
    });

    /* ── GitHub OAuth ── */

    async function exchangeGitHubToken(code, redirectUri) {
      const res = await fetch(`${CORS_PROXY_URL}/token`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ client_id: GITHUB_CLIENT_ID, code, redirect_uri: redirectUri }),
      });
      const data = await res.json();
      if (data.error || !data.access_token) {
        throw new Error(data.error_description || data.error || 'Token exchange failed');
      }
      let username = data.username;
      if (!username) {
        const userRes = await fetch('https://api.github.com/user', {
          headers: { Authorization: `Bearer ${data.access_token}`, Accept: 'application/vnd.github+json' },
        });
        if (userRes.ok) username = (await userRes.json()).login;
      }
      return { token: data.access_token, username: username || '' };
    }

    async function connectGitHub() {
      const redirectUri = OAUTH_CALLBACK_ORIGIN + '/';
      const authUrl = new URL('https://github.com/login/oauth/authorize');
      authUrl.searchParams.set('client_id', GITHUB_CLIENT_ID);
      authUrl.searchParams.set('redirect_uri', redirectUri);
      authUrl.searchParams.set('state', crypto.randomUUID());
      authUrl.searchParams.set('scope', 'read:user');

      const width = 500, height = 600;
      const left = window.screenX + (window.innerWidth - width) / 2;
      const top = window.screenY + (window.innerHeight - height) / 2;

      return new Promise((resolve, reject) => {
        const popup = window.open(
          authUrl.toString(), 'github-oauth',
          `width=${width},height=${height},left=${left},top=${top},popup=yes`
        );
        if (!popup) { reject(new Error('Popup blocked — allow popups for this site')); return; }

        const handleMessage = async (event) => {
          if (event.origin !== OAUTH_CALLBACK_ORIGIN) return;
          const { type, code, error } = event.data || {};
          if (type !== 'oauth-callback') return;
          window.removeEventListener('message', handleMessage);
          clearInterval(pollTimer);
          if (error) { reject(new Error(error)); return; }
          if (!code) { reject(new Error('No code received')); return; }
          try { resolve(await exchangeGitHubToken(code, redirectUri)); } catch (err) { reject(err); }
        };

        window.addEventListener('message', handleMessage);
        const pollTimer = setInterval(() => {
          if (popup.closed) {
            clearInterval(pollTimer);
            window.removeEventListener('message', handleMessage);
            reject(new Error('OAuth flow cancelled'));
          }
        }, 500);
      });
    }

    function updateGitHubAuthBar() {
      const bar = document.getElementById('github-auth-bar');
      if (!bar) return;
      bar.innerHTML = '';
      if (currentProvider !== 'github') return;

      if (githubAuth) {
        const label = document.createElement('span');
        label.className = 'github-user-label';
        label.textContent = `@${githubAuth.username}`;
        const disconnectBtn = document.createElement('button');
        disconnectBtn.className = 'github-disconnect-btn';
        disconnectBtn.textContent = 'Disconnect';
        disconnectBtn.addEventListener('click', () => {
          githubAuth = null;
          localStorage.removeItem('webmcp-gh-auth');
          conversationMessages = [];
          ghMessages = [];
          chatMessages.innerHTML = '';
          renderQuickActions();
          updateGitHubAuthBar();
        });
        bar.append(label, disconnectBtn);
      } else {
        const connectBtn = document.createElement('button');
        connectBtn.className = 'github-connect-btn';
        connectBtn.textContent = 'Connect GitHub';
        connectBtn.addEventListener('click', async () => {
          connectBtn.textContent = 'Connecting\u2026';
          connectBtn.disabled = true;
          try {
            githubAuth = await connectGitHub();
            localStorage.setItem('webmcp-gh-auth', JSON.stringify(githubAuth));
            updateGitHubAuthBar();
          } catch (err) {
            if (err.message !== 'OAuth flow cancelled') appendMessage('error', err.message);
            connectBtn.textContent = 'Connect GitHub';
            connectBtn.disabled = false;
          }
        });
        bar.appendChild(connectBtn);
      }
    }

    // Auto-resize textarea
    chatInput.addEventListener('input', () => {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 140) + 'px';
    });

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    chatSend.addEventListener('click', () => sendMessage());

    chatAbort.addEventListener('click', () => {
      if (abortController) abortController.abort();
    });

    function renderMarkdown(text) {
      return DOMPurify.sanitize(marked.parse(text));
    }

    function appendMessage(type, content) {
      const empty = chatMessages.querySelector('.chat-empty');
      if (empty) empty.remove();

      const el = document.createElement('div');
      el.className = `msg msg-${type}`;
      if (type === 'assistant') {
        el.innerHTML = renderMarkdown(content);
      } else {
        el.textContent = content;
      }
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return el;
    }

    function appendToolMsg(toolName, args, result, isError) {
      const empty = chatMessages.querySelector('.chat-empty');
      if (empty) empty.remove();

      const el = document.createElement('div');
      el.className = 'msg-tool-card' + (isError ? ' error' : '');

      const header = document.createElement('div');
      header.className = 'msg-tool-header';

      const status = document.createElement('span');
      status.className = 'msg-tool-status ' + (isError ? 'error' : 'success');
      status.textContent = isError ? '\u2717' : '\u2713';

      const label = document.createElement('span');
      label.className = 'msg-tool-label';
      const resultStr = typeof result === 'string' ? result : '';
      const summary = resultStr.length > 50 ? resultStr.slice(0, 50) + '...' : resultStr;
      const nameStrong = document.createElement('strong');
      nameStrong.className = 'msg-tool-name';
      nameStrong.textContent = toolName;
      label.append(nameStrong, summary ? ' \u2014 ' + summary : '');

      const chevron = document.createElement('span');
      chevron.className = 'msg-tool-chevron';
      chevron.textContent = '\u25BE';

      header.append(status, label, chevron);
      el.appendChild(header);

      const body = document.createElement('div');
      body.className = 'msg-tool-body';

      const argsEl = document.createElement('div');
      argsEl.className = 'msg-tool-args';
      argsEl.textContent = JSON.stringify(args, null, 2);
      body.appendChild(argsEl);

      if (resultStr) {
        const resultEl = document.createElement('div');
        resultEl.className = 'msg-tool-result';
        resultEl.textContent = '\u2192 ' + resultStr;
        body.appendChild(resultEl);
      }

      el.appendChild(body);

      header.addEventListener('click', () => {
        el.classList.toggle('expanded');
      });

      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function appendDivider(text) {
      const el = document.createElement('div');
      el.className = 'chat-divider';
      el.textContent = text;
      chatMessages.appendChild(el);
    }

    function showSpinner() {
      const el = document.createElement('div');
      el.className = 'chat-spinner';
      el.id = 'chat-spinner';
      el.innerHTML = '<span></span><span></span><span></span>';
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function hideSpinner() {
      const s = document.getElementById('chat-spinner');
      if (s) s.remove();
    }

    function setInputEnabled(enabled) {
      chatBusy = !enabled;
      chatInput.disabled = !enabled;
      chatSend.hidden = !enabled;
      chatAbort.hidden = enabled;
    }

    async function sendMessage(opts = {}) {
      const text = opts.prompt || chatInput.value.trim();
      const displayText = opts.display || text;
      if (!text || chatBusy) return;

      if (currentProvider === 'github') {
        if (!githubAuth?.token) {
          appendMessage('error', 'Connect your GitHub account above.');
          return;
        }
      } else if (currentProvider !== 'local') {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          appendMessage('error', 'Enter your Anthropic API key above.');
          return;
        }
      }

      const quickActions = document.getElementById('quick-actions');
      if (quickActions) quickActions.remove();
      clearFollowupSuggestions();

      appendMessage('user', displayText);
      chatInput.value = '';
      chatInput.style.height = 'auto';

      if (currentProvider === 'github') {
        ghMessages.push({ role: 'user', content: text });
      } else {
        conversationMessages.push({ role: 'user', content: text });
      }
      abortController = new AbortController();
      setInputEnabled(false);
      showSpinner();

      const apiKey = currentProvider === 'local' ? null : apiKeyInput.value.trim();
      await runConversation(apiKey, abortController.signal);

      abortController = null;
      setInputEnabled(true);
      chatInput.focus();
    }

    /* ── Streaming API ── */

    async function streamClaudeAPI(apiKey, messages, signal, proxyUrl = null) {
      const url = proxyUrl || 'https://api.anthropic.com/v1/messages';
      const headers = { 'Content-Type': 'application/json' };
      if (!proxyUrl) {
        headers['x-api-key'] = apiKey;
        headers['anthropic-version'] = '2023-06-01';
        headers['anthropic-dangerous-direct-browser-access'] = 'true';
      }
      const res = await fetch(url, {
        method: 'POST',
        signal,
        headers,
        body: JSON.stringify({
          model: modelSelect.value.split(':').slice(1).join(':'),
          max_tokens: 1024,
          system: getSystemPrompt(),
          messages,
          tools: getClaudeTools(),
          stream: true
        })
      });

      if (!res.ok) {
        const body = await res.text();
        throw new Error(`API ${res.status}: ${body.slice(0, 200)}`);
      }

      return res.body;
    }

    async function* readStreamLines(body) {
      const reader = body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() ?? '';
          for (const line of lines) yield line;
        }
      } finally {
        reader.releaseLock();
      }
    }

    async function* parseSSEStream(body) {
      let currentEvent = null;
      for await (const line of readStreamLines(body)) {
        if (line.startsWith('event: ')) {
          currentEvent = line.slice(7).trim();
        } else if (line.startsWith('data: ') && currentEvent) {
          try { yield { event: currentEvent, data: JSON.parse(line.slice(6)) }; } catch {}
          currentEvent = null;
        }
      }
    }

    async function* parseOpenAIStream(body) {
      for await (const line of readStreamLines(body)) {
        if (!line.startsWith('data: ')) continue;
        const payload = line.slice(6).trim();
        if (payload === '[DONE]') return;
        try { yield JSON.parse(payload); } catch {}
      }
    }

    async function runConversationGitHub(signal) {
      const token = githubAuth?.token;
      const modelName = modelSelect.value.split(':').slice(1).join(':');
      while (true) {
        let body;
        try {
          const res = await fetch(GITHUB_API_URL, {
            method: 'POST',
            signal,
            headers: { 'content-type': 'application/json', 'authorization': `Bearer ${token}` },
            body: JSON.stringify({
              model: modelName,
              messages: [{ role: 'system', content: getSystemPrompt() }, ...ghMessages],
              tools: getOpenAITools(),
              tool_choice: 'auto',
              max_completion_tokens: 1024,
              stream: true
            })
          });
          if (!res.ok) {
            hideSpinner();
            const txt = await res.text();
            appendMessage('error', `GitHub API ${res.status}: ${txt.slice(0, 200)}`);
            return;
          }
          body = res.body;
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', err.message);
          return;
        }

        let currentTextEl = null;
        let currentTextContent = '';
        let rafId = 0;
        const tcMap = {};

        try {
          for await (const chunk of parseOpenAIStream(body)) {
            const delta = chunk.choices?.[0]?.delta;
            if (!delta) continue;

            if (delta.content) {
              if (!currentTextEl) {
                hideSpinner();
                currentTextContent = '';
                currentTextEl = appendMessage('assistant', '');
              }
              currentTextContent += delta.content;
              if (!rafId) {
                rafId = requestAnimationFrame(() => {
                  rafId = 0;
                  if (currentTextEl) {
                    currentTextEl.innerHTML = renderMarkdown(currentTextContent);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                  }
                });
              }
            }

            if (delta.tool_calls) {
              for (const tc of delta.tool_calls) {
                const entry = tcMap[tc.index] ?? (tcMap[tc.index] = { id: '', name: '', arguments: '' });
                if (tc.id) entry.id = tc.id;
                if (tc.function?.name) entry.name += tc.function.name;
                if (tc.function?.arguments) entry.arguments += tc.function.arguments;
              }
            }
          }
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', 'Stream interrupted: ' + err.message);
          return;
        }

        if (rafId) { cancelAnimationFrame(rafId); if (currentTextEl) currentTextEl.innerHTML = renderMarkdown(currentTextContent); }

        const toolCalls = Object.values(tcMap);
        const assistantMsg = { role: 'assistant', content: currentTextContent || null };
        if (toolCalls.length) {
          assistantMsg.tool_calls = toolCalls.map(tc => ({
            id: tc.id, type: 'function', function: { name: tc.name, arguments: tc.arguments }
          }));
        }
        ghMessages.push(assistantMsg);

        if (toolCalls.length === 0) {
          hideSpinner();
          renderFollowupSuggestions();
          return;
        }

        const client = { requestUserInteraction: (cb) => cb() };
        for (const tc of toolCalls) {
          let args;
          try { args = JSON.parse(tc.arguments || '{}'); } catch { args = {}; }
          const def = getActiveTools().find(t => t.name === tc.name);
          let result;
          if (def) {
            if (!def.readOnlyHint) {
              const confirmed = await showConfirmDialog(def.title, args);
              if (!confirmed) {
                result = { summary: `User declined: ${def.title}` };
                appendToolMsg(tc.name, args, result.summary, true);
                ghMessages.push({ role: 'tool', tool_call_id: tc.id, content: JSON.stringify(result) });
                continue;
              }
            }
            result = await def.exec(args, client);
            appendToolMsg(tc.name, args, result.summary);
            if (result.displayed) { scrollDisplayIntoView(); appendDivider(getPageContext().join(' \u00b7 ')); }
          } else {
            result = { error: `Unknown tool: ${tc.name}` };
            appendToolMsg(tc.name, args, result.error, true);
          }
          ghMessages.push({ role: 'tool', tool_call_id: tc.id, content: JSON.stringify(result) });
        }
        showSpinner();
      }
    }

    async function runConversation(apiKey, signal) {
      if (currentProvider === 'github') return runConversationGitHub(signal);

      const proxyUrl = currentProvider === 'local' ? LOCAL_PROXY_URL : null;
      while (true) {
        let body;
        try {
          body = await streamClaudeAPI(apiKey, conversationMessages, signal, proxyUrl);
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', err.message);
          return;
        }

        const contentBlocks = [];
        let currentTextEl = null;
        let currentTextContent = '';
        let currentToolInput = '';
        let currentBlockType = null;
        let mdRenderPending = 0;

        try {
          for await (const { event, data } of parseSSEStream(body)) {
            switch (event) {
              case 'content_block_start': {
                const block = data.content_block;
                currentBlockType = block.type;
                if (block.type === 'text') {
                  hideSpinner();
                  currentTextContent = block.text || '';
                  currentTextEl = appendMessage('assistant', currentTextContent);
                } else if (block.type === 'tool_use') {
                  contentBlocks.push({ type: 'tool_use', id: block.id, name: block.name, input: {} });
                  currentToolInput = '';
                }
                break;
              }

              case 'content_block_delta': {
                if (data.delta.type === 'text_delta') {
                  currentTextContent += data.delta.text;
                  if (currentTextEl) {
                    if (!mdRenderPending) {
                      mdRenderPending = requestAnimationFrame(() => {
                        mdRenderPending = 0;
                        if (currentTextEl) {
                          currentTextEl.innerHTML = renderMarkdown(currentTextContent);
                        }
                      });
                    }
                  }
                } else if (data.delta.type === 'input_json_delta') {
                  currentToolInput += data.delta.partial_json;
                }
                break;
              }

              case 'content_block_stop': {
                if (currentBlockType === 'text' && currentTextContent) {
                  if (mdRenderPending) { cancelAnimationFrame(mdRenderPending); mdRenderPending = 0; }
                  if (currentTextEl) currentTextEl.innerHTML = renderMarkdown(currentTextContent);
                  contentBlocks.push({ type: 'text', text: currentTextContent });
                  currentTextEl = null;
                  currentTextContent = '';
                } else if (currentBlockType === 'tool_use') {
                  const toolBlock = contentBlocks[contentBlocks.length - 1];
                  try {
                    toolBlock.input = currentToolInput ? JSON.parse(currentToolInput) : {};
                  } catch {
                    toolBlock.input = {};
                  }
                  currentToolInput = '';
                }
                currentBlockType = null;
                break;
              }

              case 'message_delta':
                break;
            }
          }
        } catch (err) {
          hideSpinner();
          if (err.name === 'AbortError') return;
          appendMessage('error', 'Stream interrupted: ' + err.message);
          return;
        }

        // Add the full assistant message to conversation history
        conversationMessages.push({ role: 'assistant', content: contentBlocks });

        // Check for tool use
        const toolUses = contentBlocks.filter(b => b.type === 'tool_use');
        if (toolUses.length === 0) {
          hideSpinner();
          renderFollowupSuggestions();
          return;
        }

        // Execute tools and gather results
        const client = {
          requestUserInteraction: (callback) => callback()
        };
        const toolResults = [];
        for (const tu of toolUses) {
          const def = getActiveTools().find(t => t.name === tu.name);
          let result;
          if (def) {
            if (!def.readOnlyHint) {
              const confirmed = await showConfirmDialog(def.title, tu.input);
              if (!confirmed) {
                result = { summary: `User declined: ${def.title}` };
                appendToolMsg(tu.name, tu.input, result.summary, true);
                toolResults.push({ type: 'tool_result', tool_use_id: tu.id, content: JSON.stringify(result) });
                continue;
              }
            }
            result = await def.exec(tu.input, client);
            appendToolMsg(tu.name, tu.input, result.summary);
            if (result.displayed) {
              scrollDisplayIntoView();
              appendDivider(getPageContext().join(' \u00b7 '));
            }
          } else {
            result = { error: `Unknown tool: ${tu.name}` };
            appendToolMsg(tu.name, tu.input, result.error, true);
          }
          toolResults.push({
            type: 'tool_result',
            tool_use_id: tu.id,
            content: JSON.stringify(result)
          });
        }

        conversationMessages.push({ role: 'user', content: toolResults });
        showSpinner();
      }
    }

    /* ── Init ── */

    async function init() {
      renderSkeleton();

      try {
        const res = await fetch('https://restcountries.com/v3.1/all?fields=name,population,area,region,subregion,capital,languages,currencies,flag,independent');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const raw = await res.json();

        COUNTRIES = raw.map(country => ({
          name: country.name.common,
          official: country.name.official,
          region: country.region,
          subregion: country.subregion || 'N/A',
          population: country.population,
          area: country.area || 0,
          capital: (country.capital || [])[0] || 'N/A',
          languages: Object.values(country.languages || {}).join(', ') || 'N/A',
          currencies: Object.values(country.currencies || {}).map(c => c.name).join(', ') || 'N/A',
          flag: country.flag || '',
          independent: country.independent,
          populationDensity: country.area ? Math.round(country.population / country.area) : 0
        })).sort((a, b) => b.population - a.population);
      } catch (err) {
        display.innerHTML = `<p class="msg-error">Failed to load country data: ${err.message}</p>`;
        return;
      }

      loadFlags();

      if (!decodeHashToView()) {
        renderTable(COUNTRIES);
      }

      renderQuickActions();
    }

    init();
  </script>
</body>
</html>
